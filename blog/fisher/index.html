<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <script>let thunk=()=>{let e=e=>e.trim(),t=e=>e.innerText,n=e=>{let t=e.split(" "),n=t.slice(0,-1).join(" ");return[t.at(-1),n]},i=Array.from(document.getElementsByClassName("author")).map(t).map(e).map(n),o=i[0][0],a=(Array.from(document.getElementsByClassName("affiliation")).filter(e=>"P"===e.nodeName).map(t).map(e),"April 28, 2025"),r="On the Computation of the Fisher Information in Continual Learning",l="One of the most popular methods for continual learning with deep neural networks is Elastic Weight Consolidation (EWC), which involves computing the Fisher Information. The exact way in which the Fisher Information is computed is however rarely described, and multiple different implementations for it can be found online. This blog post discusses and empirically compares several often-used implementations, which highlights that many currently reported results for EWC could likely be improved by changing the way the Fisher Information is computed.";{let e=i.map(e=>`${e[0]}, ${e[1]}`).join(" and "),t=`\n@inproceedings{${(o+"2025"+r.split(" ").slice(0,3).join("")).replace(" ","").replace(/[\p{P}$+<=>^`|~]/gu,"").toLowerCase().trim()},\n  author = {${e}},\n  title = {${r}},\n  abstract = {${l}},\n  booktitle = {ICLR Blogposts 2025},\n  year = {2025},\n  date = {${a}},\n  note = {${window.location.href}},\n  url  = {${window.location.href}}\n}\n  `.trim();document.getElementById("bibtex-box").innerText=t}{let e=i.map(e=>e[0]),t=`\n${e=e.length>2?e[0]+", et al.":2==e.length?e[0]+" & "+e[1]:e[0]}, "${r}", ICLR Blogposts, 2025.\n`.trim();document.getElementById("bibtex-academic-attribution").innerText=t}};document.addEventListener("readystatechange",function(){"complete"===document.readyState&&thunk()});</script> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>On the Computation of the Fisher Information in Continual Learning | ICLR Blogposts 2025</title> <meta name="author" content="ICLR Blog"> <meta name="description" content="One of the most popular methods for continual learning with deep neural networks is Elastic Weight Consolidation (EWC), which involves computing the Fisher Information. The exact way in which the Fisher Information is computed is however rarely described, and multiple different implementations for it can be found online. This blog post discusses and empirically compares several often-used implementations, which highlights that many currently reported results for EWC could likely be improved by changing the way the Fisher Information is computed."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2025/assets/img/iclr_favicon.ico"> <link rel="stylesheet" href="/2025/assets/css/main.css"> <link rel="canonical" href="https://starlight345.github.io/2025/blog/fisher/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/2025/assets/js/theme.js"></script> <script src="/2025/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/2025/assets/js/distillpub/template.v2.js"></script> <script src="/2025/assets/js/distillpub/transforms.v2.js"></script> <script src="/2025/assets/js/distillpub/overrides.js"></script> <d-front-matter> <script async type="text/json">{
      "title": "On the Computation of the Fisher Information in Continual Learning",
      "description": "One of the most popular methods for continual learning with deep neural networks is Elastic Weight Consolidation (EWC), which involves computing the Fisher Information. The exact way in which the Fisher Information is computed is however rarely described, and multiple different implementations for it can be found online. This blog post discusses and empirically compares several often-used implementations, which highlights that many currently reported results for EWC could likely be improved by changing the way the Fisher Information is computed.",
      "published": "April 28, 2025",
      "authors": [
        {
          "author": "Gido M. van de Ven",
          "authorURL": "https://gmvandeven.github.io/",
          "affiliations": [
            {
              "name": "KU Leuven (Belgium), TU Delft (the Netherlands)",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> </head> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2025/">ICLR Blogposts 2025</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2025/about/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/call/">call for blogposts</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/submitting/">submitting</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/reviewing/">reviewing</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2025/" rel="external nofollow noopener noopener noreferrer" target="_blank"><strong>2025</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2024/" rel="external nofollow noopener noopener noreferrer" target="_blank">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2023/" rel="external nofollow noopener noopener noreferrer" target="_blank">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener noopener noreferrer" target="_blank">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>On the Computation of the Fisher Information in Continual Learning</h1> <p>One of the most popular methods for continual learning with deep neural networks is Elastic Weight Consolidation (EWC), which involves computing the Fisher Information. The exact way in which the Fisher Information is computed is however rarely described, and multiple different implementations for it can be found online. This blog post discusses and empirically compares several often-used implementations, which highlights that many currently reported results for EWC could likely be improved by changing the way the Fisher Information is computed.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#the-continual-learning-problem">The Continual Learning Problem</a></div> <div><a href="#elastic-weight-consolidation">Elastic Weight Consolidation</a></div> <ul> <li><a href="#penalizing-important-synapses">Penalizing Important Synapses</a></li> <li><a href="#bayesian-perspective">Bayesian Perspective</a></li> </ul> <div><a href="#a-closer-look-at-the-fisher-information">A Closer Look at the Fisher Information</a></div> <div><a href="#different-ways-of-computing-the-fisher-information">Different Ways of Computing the Fisher Information</a></div> <ul> <li><a href="#exact">Exact</a></li> <li><a href="#sampling-data-points">Sampling Data Points</a></li> <li><a href="#sampling-labels">Sampling Labels</a></li> <li><a href="#empirical-fisher">Empirical Fisher</a></li> <li><a href="#batched-approximation-of-empirical-fisher">Batched Approximation of Empirical Fisher</a></li> </ul> <div><a href="#empirical-comparisons">Empirical Comparisons</a></div> <ul> <li><a href="#split-mnist">Split MNIST</a></li> <li><a href="#split-cifar-10">Split CIFAR-10</a></li> </ul> <div><a href="#conclusion-and-recommendations">Conclusion and Recommendations</a></div> </nav> </d-contents> <p>Continual learning is a rapidly growing subfield of deep learning devoted to enabling neural networks to incrementally learn new tasks, domains or classes while not forgetting previously learned ones. Such continual learning is crucial for addressing real-world problems where data are constantly changing, such as in healthcare, autonomous driving or robotics. Unfortunately, continual learning is challenging for deep neural networks, mainly due to their tendency to forget previously acquired skills when learning something new.</p> <p>Elastic Weight Consolidation (EWC)<d-cite key="kirkpatrick2017overcoming"></d-cite>, developed by Kirkpatrick and colleagues from DeepMind, is one of the most popular methods for continual learning with deep neural networks. To this day, this method is featured as a baseline in a large proportion of continual learning studies. However, in the original paper the exact implementation of EWC was not well described, and no official code was provided. A previous blog post by Huszár<d-cite key="huszar2017comment"></d-cite> already addressed an issue relating to how EWC should behave when there are more than two tasks.<d-footnote>In this blog post, I use the "online" version of EWC described by Huszár<d-cite key="huszar2017comment"></d-cite>.</d-footnote> This blog post deals with the question of how to compute the Fisher Information matrix. The Fisher Information plays a central role in EWC, but the original paper does not detail how it should be computed. Other papers using EWC also rarely describe how they compute the Fisher Information, even though various different implementations for doing so can be found online.</p> <p>The Fisher Information matrix is also frequently used in the optimization literature. There, several years ago, Kunstner and colleagues<d-cite key="kunstner2019limitations"></d-cite> discussed two ways of computing the Fisher Information — the ‘true’ Fisher and the ‘empirical’ Fisher — and based on both theory and experiments they recommended against using the empirical Fisher approximation. It seems however that this discussion has not reached the continual learning community. In fact, as we will see, the most commonly used way of computing the Fisher Information in continual learning makes even cruder approximations than the empirical Fisher.</p> <h2 id="the-continual-learning-problem">The Continual Learning Problem</h2> <p>Before diving into EWC and the computation of the Fisher Information, let me introduce the continual learning problem by means of a simple example. Say, we have a deep neural network model \(f_{\boldsymbol{\theta}}\), parameterized by weight vector \(\boldsymbol{\theta}\). This model has already been trained on a first task (or a first set of tasks, this example can work recursively), by optimizing a loss function \(\ell_{\text{old}}(\boldsymbol{\theta})\) on training data \(D_{\text{old}}\sim\mathcal{D}_{\text{old}}\). This resulted in weights \(\hat{\boldsymbol{\theta}}_{\text{old}}\). We then wish to continue training this model on a new task, by optimizing a loss function \(\ell_{\text{new}}(\boldsymbol{\theta})\) on training data \(D_{\text{new}}\sim\mathcal{D}_{\text{new}}\), in such a way that the model maintains, or possibly improves, its performance on the previously learned task(s). Unfortunately, as has been thoroughly described in the continual learning literature, if the model is continued to be trained on the new data in the standard way (i.e., optimizing \(\ell_{\text{new}}(\boldsymbol{\theta})\) with stochastic gradient descent), the typical result is <em>catastrophic forgetting</em><d-cite key="mccloskey1989catastrophic,ratcliff1990connectionist"></d-cite>: a model that is good for the new task, but no longer for the old one(s).</p> <p>In this blog post, similar to most of the deep learning work on continual learning, the focus is on supervised learning. Each data point thus consists of an input \(\boldsymbol{x}\) and a corresponding output \(y\), and our deep neural network models the conditional distribution \(p_{\boldsymbol{\theta}}(y|\boldsymbol{x})\).</p> <h2 id="elastic-weight-consolidation">Elastic Weight Consolidation</h2> <p>Now we are ready to take a detailed look at EWC. We start by formally defining this method. When training on a new task, to prevent catastrophic forgetting, rather than optimizing only the loss on the new task \(\ell_{\text{new}}(\boldsymbol{\theta})\), EWC adds an extra term to the loss that involves the Fisher Information:</p> \[\ell_{\text{EWC}}(\boldsymbol{\theta})= \ell_{\text{new}}(\boldsymbol{\theta})+\frac{\lambda}{2}\sum_{i=1}^{N_{\text{params}}} F_{\text{old}}^{i,i}(\theta^{i}-\hat{\theta}_{\text{old}}^{i})^2\] <p>In this expression, \(N_{\text{params}}\) is the number of parameters in the model, \(\theta^{i}\) is the value of parameter \(i\) (i.e., the \(i^{\text{th}}\) element of weight vector \(\boldsymbol{\theta}\)), \(F_{\text{old}}^{i,i}\) is the \(i^{\text{th}}\) diagonal element of the model’s Fisher Information matrix on the old data, and \(\lambda\) is a hyperparameter that sets the relative importance of the new task compared to the old one(s).</p> <p>EWC can be motivated from two perspectives, each of which I discuss next.</p> <h3 id="penalizing-important-synapses">Penalizing Important Synapses</h3> <p>Loosely inspired by neuroscience theories of how synapses in the brain critical for previously learned skills are protected from overwriting during subsequent learning<d-cite key="yang2009stably"></d-cite>, a first motivation for EWC is that when training on a new task, large changes to network parameters important for previously learned task(s) should be avoided. To achieve this, for each parameter \(\theta^{i}\), the term \(F_{\text{old}}^{i,i}(\theta^{i}-\hat{\theta}_{\text{old}}^{i})^2\) penalizes changes away from \(\hat{\theta}_{\text{old}}^{i}\), which was that parameter’s optimal value after training on the old data. Importantly, how strongly these changes are penalized differs between parameters. This strength is set by \(F_{\text{old}}^{i,i}\), the \(i^{\text{th}}\) diagonal element of the network’s Fisher Information matrix on the old data, which is used as a proxy for how important that parameter is for the old tasks. The diagonal elements of the Fisher are a sensible choice for this, as they measure how much the network’s output would change due to small changes in each of its parameters.</p> <h3 id="bayesian-perspective">Bayesian Perspective</h3> <p>A second motivation for EWC comes from a Bayesian perspective, because EWC can also be interpreted as performing approximate Bayesian inference on the parameters of the neural network. For this we need to take a probabilistic perspective, meaning that we view the network parameters \(\boldsymbol{\theta}\) as a random variable over which we want to learn a distribution. Then, when learning a new task, the idea behind EWC is to use the posterior distribution \(p(\boldsymbol{\theta}|D_{\text{old}})\) that was found after training on the old task(s), as the prior distribution when training on the new task. To make this procedure tractable, the Laplace approximation is used, meaning that the distribution \(p(\boldsymbol{\theta}|D_{\text{old}})\) is approximated as a Gaussian centered around \(\hat{\boldsymbol{\theta}}_{\text{old}}\) and with the Fisher Information \(F_{\text{old}}\) as precision matrix. To avoid letting the computational costs become too high, EWC sets the diagonal elements of \(F_{\text{old}}\) to zero.<d-footnote>See ref<d-cite key="ritter2018online"></d-cite> for an extension of EWC that relaxes this simplification.</d-footnote> For a more in-depth treatment of EWC from a Bayesian perspective, I refer to refs<d-cite key="huszar2017comment,aich2021elastic"></d-cite>.</p> <h2 id="a-closer-look-at-the-fisher-information">A Closer Look at the Fisher Information</h2> <p>EWC thus involves computing the diagonal elements of the network’s Fisher Information on the old data. Following the definitions and notation in Martens<d-cite key="martens2020new"></d-cite>, the \(i^{\text{th}}\) diagonal element of this Fisher Information matrix is defined as:</p> \[F_{\text{old}}^{i,i} := \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_{\text{old}}} \left[ \ \mathbb{E}_{y\sim p_{\hat{\boldsymbol{\theta}}_{\text{old}}}} \left[ \left( \left. \frac{\delta \log{p_{\boldsymbol{\theta}}\left(y|\boldsymbol{x}\right)}}{\delta \theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2 \right] \right]\] <p>In this definition, there are two expectations: (1) an outer expectation over \(\mathcal{D}_{\text{old}}\), which is the (theoretical) input distribution of the old data; and (2) an inner expectation over \(p_{\hat{\boldsymbol{\theta}}_{\text{old}}}(y|\boldsymbol{x})\), which is the conditional distribution of \(y\) given \(\boldsymbol{x}\) defined by the neural network after training on the old data. The different ways of computing the Fisher Information that can be found in the continual learning literature differ in how these two expectations are computed or approximated.</p> <h2 id="different-ways-of-computing-the-fisher-information">Different Ways of Computing the Fisher Information</h2> <h3 id="exact">Exact</h3> <p>If computational costs are not an issue, the outer expectation in the definition of \(F_{\text{old}}^{i,i}\) can be estimated by averaging over all available training data \(D_{\text{old}}\), while — in the case of a classification problem — the inner expectation can be calculated for each training sample exactly:</p> \[F_{\text{old, EXACT}}^{i,i} = \frac{1}{|D_{\text{old}}|} \sum_{\boldsymbol{x}\in D_{\text{old}}} \left( \sum_{y=1}^{N_{\text{classes}}} p_{\hat{\boldsymbol{\theta}}_{\text{old}}}\left(y|\boldsymbol{x}\right) \left( \left. \frac{\delta\log p_{\boldsymbol{\theta}}\left(y|\boldsymbol{x}\right)}{\delta\theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2 \right)\] <p>I refer to this option as <strong>EXACT</strong>, because for each sample in \(D_{\text{old}}\), the diagonal elements of the Fisher Information are computed exactly. I am not aware of many implementations of EWC that use this way of computing the Fisher Information, but one example can be found in ref<d-cite key="van2022three"></d-cite>. A disadvantage of this option is that it can be computationally costly, especially if the number of training samples and/or the number of possible classes is large, because for each training sample a separate gradient must be computed for every possible class.</p> <h3 id="sampling-data-points">Sampling Data Points</h3> <p>One way to reduce the costs of computing \(F^{i,i}_{\text{old}}\) is by estimating the outer expectation using only a subset of the old training data:</p> \[F_{\text{old, EXACT}(n)}^{i,i} = \frac{1}{n} \sum_{\boldsymbol{x}\in S_{D_{\text{old}}}^{(n)}} \left( \sum_{y=1}^{N_{\text{classes}}} p_{\hat{\boldsymbol{\theta}}_{\text{old}}}\left(y|\boldsymbol{x}\right) \left( \left. \frac{\delta\log p_{\boldsymbol{\theta}}\left(y|\boldsymbol{x}\right)}{\delta\theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2 \right)\] <p>whereby \(S_{D_{\text{old}}}^{(n)}\) is a set of \(n\) random samples from \(D_{\text{old}}\). Although this seems a natural way to reduce the computational costs of computing the Fisher Information, I am aware of only one study<d-cite key="benzing2022unifying"></d-cite> that has implemented EWC in this way. Below, we will explore EWC with this implementation using \(n=500\). I refer to this option as <strong>EXACT (\(n\)=500)</strong>, because for each data point that is considered, it is still the case that the exact version of the Fisher’s diagonal elements are computed.</p> <h3 id="sampling-labels">Sampling Labels</h3> <p>Another way to make the computation of \(F^{i,i}_{\text{old}}\) less costly is by computing the squared gradient not for all possible classes, but only for a single class per training sample. This means that the inner expectation in the definition of \(F^{i,i}_{\text{old}}\) is no longer computed exactly. To maintain an unbiased estimate of the inner expectation, Monte Carlo sampling can be used. That is, for each given training sample \(\boldsymbol{x}\), the class for which to compute the squared gradient can be selected by sampling from \(p_{\hat{\boldsymbol{\theta}}_{\text{old}}}\left(.|\boldsymbol{x}\right)\). This gives:</p> \[F_{\text{old, SAMPLE}}^{i,i} = \frac{1}{|D_{\text{old}}|} \sum_{\boldsymbol{x}\in D_{\text{old}}} \left( \left. \frac{\delta\log p_{\boldsymbol{\theta}}\left(c_{\boldsymbol{x}}|\boldsymbol{x}\right)}{\delta\theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2\] <p>whereby, independently for each \(\boldsymbol{x}\), \(c_{\boldsymbol{x}}\) is randomly sampled from \(p_{\hat{\boldsymbol{\theta}}_{\text{old}}}(.|\boldsymbol{x})\). I refer to this option as <strong>SAMPLE</strong>. This way of unbiasedly estimating the Fisher Information has been used in the implementation of EWC in refs<d-cite key="liu2018rotate,kao2021natural"></d-cite>.</p> <h3 id="empirical-fisher">Empirical Fisher</h3> <p>Another option is to compute the squared gradient only for each sample’s ground-truth class:</p> \[F_{\text{old, EMPIRICAL}}^{i,i} = \frac{1}{|D_{\text{old}}|} \sum_{\left(\boldsymbol{x},y\right)\in D_{\text{old}}} \left( \left. \frac{\delta\log p_{\boldsymbol{\theta}}\left(y|\boldsymbol{x}\right)}{\delta\theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2\] <p>Computed this way, \(F_{\text{old}}\) corresponds to the “empirical” Fisher Information matrix<d-cite key="martens2020new"></d-cite>. I therefore refer to this option as <strong>EMPIRICAL</strong>. Chaudhry and colleagues<d-cite key="chaudhry2018riemannian"></d-cite> advocated for using this option when implementing EWC. Their argument is that the “true” Fisher (i.e., the option to which in this blog post I refer as EXACT) is computationally too expensive, and that, because at a good optimum the model distribution \(p_{\hat{\boldsymbol{\theta}}_{\text{old}}}(.|\boldsymbol{x})\) approaches the ground-truth output distribution, the empirical Fisher is expected to behave in a similar manner as the true Fisher. However, as mentioned in the introduction, in the optimization literature, researchers have cautioned against using the empirical Fisher as approximation of the true Fisher<d-cite key="kunstner2019limitations"></d-cite>. Nevertheless, in continual learning, it still appears to be rather common to implement EWC using the empirical Fisher, or — as we will see next — an approximate version of the empirical Fisher.</p> <h3 id="batched-approximation-of-empirical-fisher">Batched Approximation of Empirical Fisher</h3> <p>The last option that we consider has probably come about thanks to a feature of PyTorch. Note that all of the above ways of computing \(F^{i,i}_{\text{old}}\) require access to the gradients of the individual data points, as the gradients need to be squared before being summed. However, batch-wise operations in PyTorch only allow access to the aggregated gradients, not to the individual, unaggregated gradients. In PyTorch, the above ways of computing \(F^{i,i}_{\text{old}}\) could therefore only be implemented with mini-batches of size one. Perhaps in an attempt to gain efficiency, several implementations of EWC can be found on Github that compute \(F^{i,i}_{\text{old}}\) by squaring the aggregated gradients of mini-batches of size larger than one. Indeed, popular continual learning libraries such as Avalanche<d-cite key="carta2023avalanche"></d-cite><d-footnote>See these lines of code: https://github.com/ContinualAI/avalanche/blob/c1ca18d1c44f7cc8964686efd54a79443763d945/avalanche/training/plugins/ewc.py#L161-L180</d-footnote> and PyCIL<d-cite key="zhou2023pycil"></d-cite><d-footnote>See these lines of code: https://github.com/G-U-N/PyCIL/blob/0cb8ad6ca6da93deff5e8767cfb143ed2aa05809/models/ewc.py#L234-L254</d-footnote> use this approach, which probably makes this variant of computing the Fisher the one that is most used in the continual learning literature. Typically, these batched implementations only use the gradients for the ground-truth classes (i.e., they are approximate versions of the empirical Fisher):</p> \[F_{\text{old, BATCHED}(b)}^{i,i} = \frac{1}{|D_{\text{old}}^{(b)}|} \sum_{\mathcal{B}\in D_{\text{old}}^{(b)}} \left( \sum_{\left(\boldsymbol{x},y\right)\in \mathcal{B}} \left. \frac{\delta\log p_{\boldsymbol{\theta}}\left(y|\boldsymbol{x}\right)}{\delta\theta^i} \right\rvert_{\boldsymbol{\theta}=\hat{\boldsymbol{\theta}}_{\text{old}}} \right)^2\] <p>whereby \(D_{\text{old}}^{(b)}\) is a batched version of the old training data $D_{\text{old}}$, so that the elements of \(D_{\text{old}}^{(b)}\) are mini-batches with \(b\) training samples. (And \(|D_{\text{old}}^{(b)}|\) is the number of mini-batches, not the number of training samples.) Below, we will explore this option using $b=128$, referring to it as <strong>BATCHED (b=128)</strong>.</p> <h2 id="empirical-comparisons">Empirical Comparisons</h2> <p>Now, let us empirically compare the performance of EWC with these various ways of computing the Fisher Information. To do so, I use two relatively simple, often used continual learning benchmarks: Split MNIST and Split CIFAR-10. For these benchmarks, the original MNIST or CIFAR-10 dataset is split up into five tasks with two classes per task. Both benchmarks are performed according to the task-incremental learning scenario, using a separate softmax output layer for each task. For Split MNIST, following refs<d-cite key="van2022three"></d-cite>, a fully connected network with two hidden layers of 400 ReLUs each is used. For Split CIFAR-10, following refs<d-cite key="lopez2017gradient,hess2024two"></d-cite>, a reduced ResNet-18 is used without pre-training. For both benchmarks, the Adam-optimizer<d-cite key="kingma2015adam"></d-cite> (\(\beta_1\)=0.9, \(\beta_2\)=0.999) is used to train for 2000 iterations per task with stepsize of 0.001 and mini-batch size of 128 (Split MNIST) or 256 (Split CIFAR). Performance is measured as the test accuracy (i.e., percentage of test samples classified correctly) of the final model (i.e., after finishing training on the last task) averaged over all tasks. Each experiment is run 30 times with different random seeds, and reported are the mean \(\pm\) standard error over these runs. Code to replicate these experiments is available at <a href="https://github.com/GMvandeVen/continual-learning" rel="external nofollow noopener noopener noreferrer" target="_blank">https://github.com/GMvandeVen/continual-learning</a>.</p> <h3 id="split-mnist">Split MNIST</h3> <p>For the experiments on Split MNIST, the results are shown below in a graph and a table:</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-fisher/results_MNIST-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-fisher/results_MNIST-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-fisher/results_MNIST-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-fisher/results_MNIST.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Performance of EWC with different ways of computing the Fisher on Split MNIST, for a wide range of hyperparameter values. </div> <table> <thead> <tr> <th> </th> <th><strong>Accuracy (in %)</strong></th> <th><strong>Train time (in S)</strong></th> </tr> </thead> <tbody> <tr> <td>EXACT</td> <td>99.12 ($\pm$ 0.16)</td> <td>121 ($\pm$ 1)</td> </tr> <tr> <td>EXACT ($n$=500)</td> <td>98.93 ($\pm$ 0.15)</td> <td>58 ($\pm$ 0)</td> </tr> <tr> <td>SAMPLE</td> <td>99.12 ($\pm$ 0.12)</td> <td>101 ($\pm$ 1)</td> </tr> <tr> <td>EMPIRICAL</td> <td>99.12 ($\pm$ 0.12)</td> <td>100 ($\pm$ 1)</td> </tr> <tr> <td>BATCHED ($b$=128)</td> <td>99.11 ($\pm$ 0.16)</td> <td>58 ($\pm$ 1)</td> </tr> <tr> <td><em>None</em></td> <td><em>85.41 ($\pm$ 0.88)</em></td> <td><em>53 ($\pm$ 0)</em></td> </tr> </tbody> </table> <div class="caption"> EWC with different ways of computing the Fisher on Split MNIST. Shown are the average final test accuracy for the best performing hyperparameter value of each variant, and the total training time on an NVIDIA RTX 2000 Ada Generation GPU. </div> <p>From the table we can see that for Split MNIST, when looking only at the performance of the best performing hyperparameter, there are no substantial differences between the various ways of computing the Fisher. However, there are large differences in terms of the range of hyperparameter values that EWC performs well with. For example, when using the BATCHED option of computing the Fisher, EWC requires a hyperparameter orders of magnitude larger than the best hyperparameter for the EXACT option. This suggests that there might be important differences between these different ways of computing the Fisher, but that perhaps the task-incremental version of Split MNIST is not difficult enough to elicit significant differences in the best performance between them.</p> <h3 id="split-cifar-10">Split CIFAR-10</h3> <p>Therefore, let us look at the results on the more difficult Split CIFAR-10 benchmark. Again, the results are presented in the form of a graph and a table:</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-fisher/results_CIFAR-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-fisher/results_CIFAR-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-fisher/results_CIFAR-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-fisher/results_CIFAR.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Performance of EWC with different ways of computing the Fisher on Split CIFAR-10, for a wide range of hyperparameter values. </div> <table> <thead> <tr> <th> </th> <th><strong>Accuracy (in %)</strong></th> <th><strong>Train time (in S)</strong></th> </tr> </thead> <tbody> <tr> <td>EXACT</td> <td>84.91 ($\pm$ 0.65)</td> <td>972 ($\pm$ 5)</td> </tr> <tr> <td>EXACT ($n$=500)</td> <td>84.57 ($\pm$ 0.72)</td> <td>668 ($\pm$ 1)</td> </tr> <tr> <td>SAMPLE</td> <td>83.77 ($\pm$ 0.72)</td> <td>817 ($\pm$ 2)</td> </tr> <tr> <td>EMPIRICAL</td> <td>83.28 ($\pm$ 0.77)</td> <td>817 ($\pm$ 2)</td> </tr> <tr> <td>BATCHED ($b$=128)</td> <td>83.38 ($\pm$ 0.66)</td> <td>667 ($\pm$ 1)</td> </tr> <tr> <td><em>None</em></td> <td><em>69.53 ($\pm$ 1.34)</em></td> <td><em>627 ($\pm$ 3)</em></td> </tr> </tbody> </table> <div class="caption"> EWC with different ways of computing the Fisher on Split CIFAR-10. Shown are the average final test accuracy for the best performing hyperparameter value of each variant, and the total training time on an NVIDIA RTX 2000 Ada Generation GPU. </div> <p>Indeed, on this benchmark, there are significant differences between the different options also in terms of their best performance. The performance of EWC is substantially better when the Fisher Information is computed exactly, even when this is done only for a subset of the old training data, compared to when it is estimated or approximated in same way. We can further see that the SAMPLE option, which uses an unbiased estimate of the true Fisher, appears to perform somewhat better than using the empirical Fisher, but the difference is small and non-conclusive. Interestingly, also on this more difficult benchmark, using the batched approximation of the empirical Fisher still results in a similar best performance as using the regular emprical Fisher, although these two options do differ in terms of their optimal hyperparameter range.</p> <h2 id="conclusion-and-recommendations">Conclusion and Recommendations</h2> <p>I finish this blog post by concluding that the way in which the Fisher Information is computed can have a substantial impact on the performance of EWC. This is an important realization for the continual learning research community. Going forwards, based on my findings, I have three recommendations for researchers in this field. Firstly, whenever using EWC — or another method that uses the Fisher Information — make sure to describe the details of how the Fisher Information is computed. Secondly, do not simply ‘‘use the best performing hyperparameter(s) from another paper’’, especially if you cannot guarantee that the details of your implementation are the same as in the other paper. And thirdly, when using the Fisher Information matrix, it is preferable to compute it exactly rather than approximating it. If computational resources are scarce, it might be better to reduce the number of training samples used to compute the Fisher, than to cut corners in another way.</p> <h3 id="acknowledgements">Acknowledgements</h3> <p>This work has been supported by a senior postdoctoral fellowship from the Resarch Foundation — Flanders (FWO) under grant number 1266823N.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/2025/assets/bibliography/2025-04-28-fisher.bib"></d-bibliography> <d-article id="bibtex-container" class="related highlight"> For attribution in academic contexts, please cite this work as <pre id="bibtex-academic-attribution">
        PLACEHOLDER FOR ACADEMIC ATTRIBUTION
  </pre> BibTeX citation <pre id="bibtex-box">
        PLACEHOLDER FOR BIBTEX
  </pre> </d-article> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2025" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>