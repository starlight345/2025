<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <script>let thunk=()=>{let t=t=>t.trim(),e=t=>t.innerText,n=t=>{let e=t.split(" "),n=e.slice(0,-1).join(" ");return[e.at(-1),n]},i=Array.from(document.getElementsByClassName("author")).map(e).map(t).map(n),a=i[0][0],o=(Array.from(document.getElementsByClassName("affiliation")).filter(t=>"P"===t.nodeName).map(e).map(t),"April 28, 2025"),r="A Visual Dive into Conditional Flow Matching",l="Conditional flow matching (CFM) was introduced by three simultaneous papers at ICLR 2023, through different approaches (conditional matching, rectifying flows and stochastic interpolants). <br/> The main part of this post, Section 2, explains CFM by using both visual intuitions and insights on its probabilistic formulations. Section 1 introduces nomalizing flows; it can be skipped by reader familiar with the topic, or that wants to cover them later. Section 3 opens on the links between CFM and other approaches, and ends with a 'CFM playground'.";{let t=i.map(t=>`${t[0]}, ${t[1]}`).join(" and "),e=`\n@inproceedings{${(a+"2025"+r.split(" ").slice(0,3).join("")).replace(" ","").replace(/[\p{P}$+<=>^`|~]/gu,"").toLowerCase().trim()},\n  author = {${t}},\n  title = {${r}},\n  abstract = {${l}},\n  booktitle = {ICLR Blogposts 2025},\n  year = {2025},\n  date = {${o}},\n  note = {${window.location.href}},\n  url  = {${window.location.href}}\n}\n  `.trim();document.getElementById("bibtex-box").innerText=e}{let t=i.map(t=>t[0]),e=`\n${t=t.length>2?t[0]+", et al.":2==t.length?t[0]+" & "+t[1]:t[0]}, "${r}", ICLR Blogposts, 2025.\n`.trim();document.getElementById("bibtex-academic-attribution").innerText=e}};document.addEventListener("readystatechange",function(){"complete"===document.readyState&&thunk()});</script> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>A Visual Dive into Conditional Flow Matching | ICLR Blogposts 2025</title> <meta name="author" content="ICLR Blog"> <meta name="description" content="Conditional flow matching (CFM) was introduced by three simultaneous papers at ICLR 2023, through different approaches (conditional matching, rectifying flows and stochastic interpolants). &lt;br/&gt; The main part of this post, Section 2, explains CFM by using both visual intuitions and insights on its probabilistic formulations. Section 1 introduces nomalizing flows; it can be skipped by reader familiar with the topic, or that wants to cover them later. Section 3 opens on the links between CFM and other approaches, and ends with a 'CFM playground'."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2025/assets/img/iclr_favicon.ico"> <link rel="stylesheet" href="/2025/assets/css/main.css"> <link rel="canonical" href="https://starlight345.github.io/2025/blog/conditional-flow-matching/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/2025/assets/js/theme.js"></script> <script src="/2025/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/2025/assets/js/distillpub/template.v2.js"></script> <script src="/2025/assets/js/distillpub/transforms.v2.js"></script> <script src="/2025/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}body .preamble ~ *{&:not(.definition,.theorem,.boxed){text-align:justify}}@media(max-width:1000px){.sidebar{transform-origin:top right;transform:scale(0.25,0.25);transition:transform .3s ease-in-out;&:focus-within,&:hover{transform:translate(75%,-50%);z-index:10000}&.is-right{transform-origin:top left;&:hover{transform:translate(-75%,-50%)}}}}@media(max-width:768px){.sidebar{transform:translate(30%,0) scale(0.25,0.25);&:not(:hover){opacity:.5}&:focus-within,&:hover{transform:translate(105%,-50%)}&.is-right{transform:translate(-30%,0) scale(0.25,0.25);&:hover{transform:translate(-105%,-50%)}}}}.sidebar{background:var(--sidebar-bg);border-radius:1em;width:calc(var(--w) * 1px);height:calc(var(--h) * 1px);margin-bottom:-100%;margin-left:calc(var(--w) * -1px - 20px);iframe{width:calc(var(--w) * 1px)}figcaption,.caption{padding:0 1em}text-align:right}.is-right{position:relative;left:calc(var(--w) * 1px - -100% - -40px)}iframe{aspect-ratio:var(--w) / var(--h)}.preamble{width:0;height:0;overflow:hidden}.preamble{counter-reset:all-theorems all-figures all-definitions}.theorem,.definition,.boxed{--l-fg:60;--h-box:230;&.theorem{counter-increment:all-theorems;--env-type:"Theorem "}&.definition{counter-increment:all-definitions;--env-type:"Definition "}border:2px solid lch(var(--l-fg) 60 var(--h-box));padding:1em;&.boxed>:first-child,&:not(.boxed)::before{font-weight:bold;content:var(--env-type) counter(all-theorems);display:inline-block;position:relative;margin:0;top:-1em;left:-1em;padding:.3em 1em;color:var(--global-bg-color)!important;background:lch(var(--l-fg) 60 var(--h-box))}}.ref-lastth::after{content:counter(all-theorems)}.ref-lastdef::after{content:counter(all-definitions)}figure>figcaption:not(:has(p)),figure>figcaption>p:first-child{counter-increment:all-figures;&::before{display:inline;content:"Figure " counter(all-figures) ". "}}.fig-push{counter-increment:all-figures;width:0;visibility:hidden}.fig-pop{counter-increment:all-figures -1;width:0;visibility:hidden}.ref-lastfig::after{content:counter(all-figures)}.left-lined{margin-left:-3px;border-left:3px solid gray;padding-left:1em;margin-bottom:1em;display:grid}html{--l-bg:70;--l-fg:50;--summary-text:darkblue;--sidebar-bg:#EEE}html[data-theme="dark"]{--l-bg:50;--l-fg:70;--sidebar-bg:#333;--summary-text:lightblue;.invert{filter:invert()}}.summary-table td:nth-of-type(n+2){&,strong,mjx-container{color:black!important}}details{border-left:2px solid grey;&:not([open]){border-left-color:transparent}padding-left:2em;summary{margin-left:-1.5em;color:var(--summary-text)!important}}.grid-custom1{display:grid;grid-template-rows:0fr 1fr 0fr 1fr;grid-template-columns:1fr 1fr 1fr 0fr 1fr;align-items:center;justify-items:center;row-gap:0;}figcaption,.figcaption{color:var(--global-text-color)!important}summary{color:var(--global-text-color)!important}html[data-theme="dark"]{.grid-custom1 img{padding-top:1em;background:white}mjx-container{color:var(--global-text-color)}}:target{scroll-margin-top:150px;background:rgb(255 255 0 / .1)}d-math{color:darkred!important;background yellow!important;border:1px solid darkred;&::after{position:relative;font-size:50%;top:-1.5em;left:-3em;width:0;overflow:visible;white-space:pre;display:inline-block;content:"KATEX USED, SIMPLE DOLLAR?"}&:not(:hover)::after{opacity:0}}.maybe-done:not(:hover){background:lightgray;border:2px solid var(--whocol);display:block;&em{display:inline-block}width:10px;height:10px;overflow:hidden}</style> <d-front-matter> <script async type="text/json">{
      "title": "A Visual Dive into Conditional Flow Matching",
      "description": "Conditional flow matching (CFM) was introduced by three simultaneous papers at ICLR 2023, through different approaches (conditional matching, rectifying flows and stochastic interpolants). <br/> The main part of this post, Section 2, explains CFM by using both visual intuitions and insights on its probabilistic formulations. Section 1 introduces nomalizing flows; it can be skipped by reader familiar with the topic, or that wants to cover them later. Section 3 opens on the links between CFM and other approaches, and ends with a 'CFM playground'.",
      "published": "April 28, 2025",
      "authors": [
        {
          "author": "Anne Gagneux",
          "authorURL": "https://annegnx.github.io",
          "affiliations": [
            {
              "name": "INRIA, ENS de Lyon",
              "url": ""
            }
          ]
        },
        {
          "author": "Ségolène Martin",
          "authorURL": "https://segolenemartin.github.io/",
          "affiliations": [
            {
              "name": "Technische Universität Berlin",
              "url": ""
            }
          ]
        },
        {
          "author": "Rémi Emonet",
          "authorURL": "https://home.heeere.com/",
          "affiliations": [
            {
              "name": "Inria, Université Jean Monnet",
              "url": ""
            }
          ]
        },
        {
          "author": "Quentin Bertrand",
          "authorURL": "https://qb3.github.io/",
          "affiliations": [
            {
              "name": "Inria, Université Jean Monnet",
              "url": ""
            }
          ]
        },
        {
          "author": "Mathurin Massias",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Inria, ENS de Lyon",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> </head> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2025/">ICLR Blogposts 2025</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2025/about/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/call/">call for blogposts</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/submitting/">submitting</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/reviewing/">reviewing</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2025/" rel="external nofollow noopener noopener noreferrer" target="_blank"><strong>2025</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2024/" rel="external nofollow noopener noopener noreferrer" target="_blank">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2023/" rel="external nofollow noopener noopener noreferrer" target="_blank">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener noopener noreferrer" target="_blank">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>A Visual Dive into Conditional Flow Matching</h1> <p>Conditional flow matching (CFM) was introduced by three simultaneous papers at ICLR 2023, through different approaches (conditional matching, rectifying flows and stochastic interpolants). <br> The main part of this post, Section 2, explains CFM by using both visual intuitions and insights on its probabilistic formulations. Section 1 introduces nomalizing flows; it can be skipped by reader familiar with the topic, or that wants to cover them later. Section 3 opens on the links between CFM and other approaches, and ends with a 'CFM playground'.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#introduction-to-generative-modelling-with-normalizing-flows">Introduction to Generative Modelling with Normalizing Flows</a></div> <ul> <li><a href="#normalizing-flows">Normalizing Flows</a></li> <li><a href="#continuous-normalizing-flows">Continuous Normalizing Flows</a></li> </ul> <div><a href="#conditional-flow-matching">Conditional Flow Matching</a></div> <ul> <li><a href="#intuition-of-conditional-flow-matching">Intuition of Conditional Flow Matching</a></li> <li><a href="#modelling-choices">Modelling Choices</a></li> <li><a href="#from-conditional-to-unconditional-velocity">From Conditional to Unconditional Velocity</a></li> </ul> <div><a href="#going-further">Going Further</a></div> <ul> <li><a href="#fast-sampling-with-straight-flows">Fast Sampling with Straight Flows</a></li> <li><a href="#diffusion-models">Diffusion Models</a></li> <li><a href="#link-between-diffusion-and-flow-matching">Link Between Diffusion and Flow-Matching</a></li> <li><a href="#cfm-playground">CFM Playground</a></li> </ul> <div><a href="#references">References</a></div> </nav> </d-contents> <div class="preamble"> $$ \def\partialt#1{\frac{\partial #1}{\partial t}} \def\|{|} \def\p{p(x | t)} \def\u{u(x, t)} \def\utheta{u_{\theta}(x, t)} \def\uthetacfm{u_{\theta}^{\mathrm{CFM}}(x, t)} \def\pcond{p(x | t, z)} \def\ucond{u^{\mathrm{cond}}(x, t, z)} \def\ucondzi{u^{\mathrm{cond}}(x, t, z^{(i)})} \def\wcond{p^{|x,t}(z)} \def\pcondi{p(x | z_i, t)} \def\ucondi{u^{\mathrm{cond}}(x, t, z_i)} \def\E#1#2{\mathbb{E}_{#1} #2} \def\Ebracket#1#2{\mathbb{E}_{#1} \left[ #2 \right]} \def\ucondcustom#1{u^{\mathrm{cond}}(#1)} \def\pdata{p_{\mathrm{data}} } \newcommand{\cL}{\mathcal{L}} \def{\cLL}{\mathcal{L}} \newcommand{\cN}{\mathcal{N}} \newcommand{\cC}{\mathcal{C}} \newcommand{\cO}{\mathcal{O}} \newcommand{\bbE}{\mathbb{E}} \newcommand{\bbN}{\mathbb{N}} \newcommand{\KL}{\mathrm{KL}} $$ </div> <p>All authors contributed equally to this work.</p> <p>The first part of the blog post is an introduction to generative modelling, normalizing flows and continuous normalizing flows. The reader already familiar with these topics, or that wants to cover them later, can directly jump to the <a href="#conditional-flow-matching">second part</a>, devoted to <strong>conditional flow matching</strong>.</p> <h2 id="introduction-to-generative-modelling-with-normalizing-flows">Introduction to Generative Modelling with Normalizing Flows</h2> <p>In a nutshell, the task of generative modelling consists in learning how to sample from a distribution \(p_{\mathrm{data}}\) given a finite number of samples \(x^{(1)}, \ldots, x^{(n)} \in \mathbb{R}^d\) drawn from \(p_{\mathrm{data}}\). It comes with three main challenges – the so-called “Generative learning trilemma” <d-cite key="xiao2021tackling"></d-cite>:</p> <ul> <li>enforce fast sampling</li> <li>generate high quality samples</li> <li>properly cover the diversity of \(p_{\mathrm{data}}\)</li> </ul> <p>One may also add to this wishlist that the model should be easy to train.</p> <p>The modern approach to generative modelling consists in picking a simple <em>base distribution</em> \(p_0\), typically an isotropic Gaussian \(\mathcal{N}(0, \mathrm{Id}_d)\), and learning a map \(T: \mathbb{R}^d \to \mathbb{R}^d\) such that when \(x\) follows \(p_0\) <em>(i.e., \(x \sim p_0\))</em>, the distribution of \(T(x)\) is as close as possible to \(p_{\mathrm{data}}\)<d-footnote>In all this post, by abuse of language we may use "distribution" when referring to densities; all densities are assumed strictly positive everywhere so that Kullback-Leibler divergences and logarithms are well defined.</d-footnote>.</p> <p>When \(x \sim p_0\), the distribution of \(T(x)\) is denoted as \(T\#p_0\), and called the <em>pushforward</em> of \(p_0\) by \(T\)<d-footnote><span>The pushforward of the measure \(\mu\) by the map \(T\), \(T\#\mu\), is defined as \(T\#\mu(A) = \mu(T^{-1}(A))\) for all \(A\subset \mathbb{R}^d\). If the random variable \(x\) has law \(\mu\), the random variable \(T(x)\) has law \(T\#\mu\).</span></d-footnote>. Once the map \(T\) is learned, one can simply sample \(x\) from \(p_0\) and use \(T(x)\) as a generated sample from \(p_\mathrm{data}\).</p> <p>Two intertwined questions arise: what kind of map \(T\) to use, and how to learn it? A natural idea is to define \(T\) as a parametric map \(T_\theta\), typically a neural network, and to learn the optimal parameters \(\theta^*\) by maximizing the log-likelihood of the available samples<d-footnote>Note there also exist generative methods based on other principles, e.g. GANs, that are not covered in this blogpost.</d-footnote>:</p> \[\begin{equation}\label{eq:log_lik} \theta^* = \mathop{\mathrm{argmax}}_\theta \sum_{i=1}^n \log \left( (T_\theta \# p_0)(x^{(i)}) \right) \,. \end{equation}\] <p>Approximately, maximizing the log-likelihood in \eqref{eq:log_lik} corresponds to making \(p_{\mathrm{data}}\) and \(T_\theta\#p_0\) close in the sense of the Kullback-Leibler divergence<d-footnote><span> Indeed \(\begin{aligned} \mathop{\mathrm{KL}(p_{\mathrm{data}}, T_\theta\#p_0)} &amp; \overset{\mathrm{def}}{=} \int_x \log \left(\frac{p_{\mathrm{data}}(x)}{T_\theta\#p_0(x)}\right) p_{\mathrm{data}}(x) \, \mathrm{d}x \\ &amp; = \int_x \log (p_{\mathrm{data}}(x)) p_{\mathrm{data}}(x) \, \mathrm{d}x - \int_x \log (T_\theta\#p_0(x)) p_{\mathrm{data}}(x) \, \mathrm{d}x \ . \end{aligned}\) When minimizing with respect to \(\theta\) the first term of the right hand side is constant and can be ignored. The second term is simply \(-\mathbb{E}_{x \sim p_{\mathrm{data}}} [\log T_\theta\#p_0(x)]\): approximating it by an empirical mean using \(x^{(1)}, \ldots, x^{(n)}\) yields the objective in \eqref{eq:log_lik}.</span></d-footnote>.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/T_theta_pushforward.svg-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/T_theta_pushforward.svg-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/T_theta_pushforward.svg-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/T_theta_pushforward.svg" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption">Modern generative modelling principle: trying to find a map \(T\) that sends the base distribution \(p_0\) as close as possible to the data distribution \(p_{\mathrm{data}}\).</figcaption> </figure> <h3 id="normalizing-flows">Normalizing Flows</h3> <p>In order to compute the log-likelihood objective function in \eqref{eq:log_lik}, if \(T_\theta\) is a diffeomorphism (and thus has a differentiable inverse \(T_\theta^{-1}\)), one can rely on the so-called <em>change-of-variable formula</em></p> \[\begin{equation}\label{eq:change_variable} \log p_1(x) = \log p_0(T_\theta^{-1}(x)) + \log |\det J_{T_\theta^{-1}}(x)| \end{equation}\] <p>where \(J_{T_\theta^{-1}}\in \mathbb{R}^{d\times d}\) is the Jacobian of \(T^{-1}_{\theta}\). Relying on this formula to evaluate the likelihood imposes two constraints on the network:</p> <ul> <li>\(T_\theta\) must be invertible; in addition \(T_{\theta}^{-1}\) should be easy to compute in order to evaluate the first right-hand side term in \eqref{eq:change_variable}</li> <li>\(T_\theta^{-1}\) must be differentiable, and the (log) determinant of the Jacobian of \(T_\theta^{-1}\) must not be too costly to compute in order to evaluate the second right-hand side term in \eqref{eq:change_variable}<d-footnote><span>Equivalently, both \(T^{-1}_\theta\) and the determinant of \(J_{T_\theta}\) must be easy to compute, since \(J_{T_\theta^{-1}}(x) = (J_{T_\theta}(T_\theta^{-1}(x)))^{-1}\) and \(\log|\det J_{T_\theta^{-1}}(x) | = - \log | \det J_{T_\theta}(T_\theta^{-1}(x))|\).</span></d-footnote>.</li> </ul> <p>The philosophy of Normalizing Flows (NFs) <d-cite key="tabak2013family,rezende2015variational,papamakarios2021normalizing"></d-cite> is to design special neural architectures satisfying these two requirements. Normalizing flows are maps \(T_\theta = \phi_K \circ \ldots \phi_1\), where each \(\phi_k\) is a simple transformation satisfying the two constraints – and hence so does \(T_\theta\). Let \(x_0 \sim p_0\) and \(x_{k} = \phi_k(x_{k-1})\) for \(k\in\{1, \ldots, K\}\), the chain rule yields the following formula for the log-likelihood </p> \[\begin{align*} \log p_1(x_K) &amp;= \log p_0(\phi_1^{-1} \circ \ldots \circ \phi_K^{-1} (x_K)) + \log |\det J_{\phi_1^{-1} \circ \ldots \circ \phi_K^{-1}}(x_K)| \\ &amp;= \log p_0(\phi_1^{-1} \circ \ldots \circ \phi_K^{-1} (x_K)) + \sum_{k=1}^{K} \log | \det J_{\phi^{-1}_k}(x_{k}) | \end{align*}\] <p>which is still easy to evaluate provided each \(\phi_k\) satisfies the two constraints.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/normalizing_flow_cross-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/normalizing_flow_cross-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/normalizing_flow_cross-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/normalizing_flow_cross.png" class="img-fluid invert" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption">Normalizing flow with \(K=4\), transforming an isotropic Gaussian (leftmost) to a cross shape target distribution (rightmost). Picture from <d-cite key="papamakarios2021normalizing"></d-cite></figcaption> </figure> <p>For example, one of the earliest instances of NF is the planar flow, which uses as building blocks</p> \[\phi_k(x) = x + \sigma(b_k^\top x + c) a_k\] <p>with \(a_k, b_k \in \mathbb{R}^d\), \(c \in \mathbb{R}\), and \(\sigma :\mathbb{R} \to \mathbb{R}\) a non linearity applied pointwise.<d-footnote>The Jacobian of a planar flow block is \(J_{\phi_k}(x)= \mathrm{Id}_d + \sigma'(b_k^\top x + c) a_k b_k^\top\) whose determinant can be computed in \(\mathcal{O}(d)\) through the matrix determinant lemma \(\det (\mathrm{Id} + x y^\top) = 1 + x^\top y\). However, \(\phi_k^{-1}\) does not admit an analytical expression, and one must resort to iterative algorithms such as Newton's method to approximate it. </d-footnote></p> <p>A more complex example of NF, that satisfies both constraints, is Real NVP <d-cite key="dinh2017density"></d-cite>.</p> <details> <summary>Click here for details about Real NVP</summary> <div> \[\begin{equation}\label{eq:realnvp} \begin{aligned} \phi(x)_{1:d'} &amp;= x_{1:d'}\\ \phi(x)_{d':d} &amp;= x_{d':d} \odot \exp(s(x_{1:d'})) + t(x_{1:d'}) \end{aligned} \end{equation}\] <p>where \(d' \leq d\) and the so-called <em>scale</em> \(s\) and <em>translation</em> \(t\) are functions from \(\mathbb{R}^{d'}\) to \(\mathbb{R}^{d-d'}\), parametrized by neural networks. This transformation is invertible in closed-form, and the determinant of its Jacobian is cheap to compute.</p> <p>The Jacobian of \(\phi\) defined in \eqref{eq:realnvp} is lower triangular:</p> \[J_{\phi}(x) = \begin{pmatrix} \mathrm{Id}_{d'} &amp; 0_{d',d -d'} \\ ... &amp; \mathrm{diag}(\exp(s(x_{1:d}))) \end{pmatrix}\] <p>hence its determinant can be computed at a low cost, and in particular without computing the Jacobians of \(s\) and \(t\). In addition, \(\phi\) is easily invertible:</p> <p>\(\begin{align*} \phi^{-1}(y)_{1:d'} &amp;= y_{1:d'} \\ \phi^{-1}(y)_{d':d} &amp;= (y_{d':d} - t(y_{1:d'})) \odot \exp(- s(y_{1:d'})) \end{align*}\)</p> </div> </details> <p><br> It has met with a huge success in practice and a variety of alternative NFs have been proposed<d-cite key="tomczak2016improving,kingma2016improved,van2018sylvester"></d-cite>. Unfortunately, the architectural constraints on Normalizing Flows tends to hinder their expressivity<d-footnote>Alternative solutions exist, for example relying on invertible ResNets <d-cite key="behrmann2019invertible"></d-cite> or the recently proposed free form normalizing flows <d-cite key="draxler2024free"></d-cite>, that are out of scope for this blog post.</d-footnote>.</p> <h3 id="continuous-normalizing-flows">Continuous Normalizing Flows</h3> <p>A successful solution to this expressivity problem is based on an idea similar to that of ResNets, named Continuous Normalizing Flows (CNF) <d-cite key="chen2018neural"></d-cite>. If we return to the planar normalizing flow, by letting \(u_{k-1}(\cdot) \overset{\mathrm{def}}{=} K\sigma(b_k^\top \cdot + c) a_k\), we can rewrite the relationship between \(x_{k}\) and \(x_{k-1}\) as:</p> <figure class="sidebar" style="--w: 200; --h: 320;"> <iframe style="--h: 200" src="/2025/assets/html/2025-04-28-conditional-flow-matching/ot-flow-1d.html#loop1" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">From a direct mapping, to finer and finer time discretizations, to a continuous-time mapping.</figcaption> </figure> \[\begin{align*} x_k &amp;= \phi_k(x_{k-1}) \\ &amp;= x_{k-1} + \sigma(b_k^\top x_{k-1} + c) a_k \\ &amp;= x_{k-1} + \frac{1}{K} u_{k-1}(x_{k-1}) \\ \end{align*}\] <p>which can be interpreted as a forward Euler discretization, with step \(1/K\), of the ODE</p> <p>\(\begin{equation}\label{eq:initial_value_pb} \begin{cases} x(0) = x_0 \\ \partial_t x(t) = u(x(t), t) \quad \forall t \in [0, 1] \end{cases} \end{equation}\) Note that the mapping defined by the ODE, \(T(x_0):= x(1)\) is inherently invertible because one can solve the <em>reverse-time</em> ODE (from \(t=1\) to \(0\)) with the initial condition \(x(1)=T(x_0)\).</p> <p>This ODE is called an <em>initial value problem</em>, controlled by the <strong>velocity field</strong> \(u: \mathbb{R}^{d} \times [0, 1] \to \mathbb{R}^d\). In addition to \(u\), it is related to two other fundamental objects:</p> <ul> <li>the <strong>flow</strong> \(f^u: \mathbb{R}^d \times[0, 1] \to \mathbb{R}^d\), with \(f^u(x, t)\) defined as the solution at time \(t\) to the initial value problem driven by \(u\) with initial condition \(x(0) = x\). </li> <li>the <strong>probability path</strong> \((p_t)_{t\in[0,1]}\), defined by \(p_t = f^u(\cdot, t)\# p_0\), i.e., \(p_t\) is the distribution of \(f^u(x, t)\) when \(x \sim p_0\).</li> </ul> <p>A fundamental equation linking \(p_t\) and \(u\) is the <em>continuity equation</em>, also called transport equation:</p> \[\begin{equation}\label{eq:continuity_eq} \partial_t p_t + \nabla\cdot u_t p_t = 0 \end{equation}\] <p>Under technical conditions and up to divergence-free vector fields, for a given \(p_t\) (resp. \(u\)) there exists a \(u\) (resp. \(p_t\)) such that the pair \((p_t, u)\) solves the continuity equation<d-footnote><span>If \((p_t)_t\) is absolutely continuous and \(∣\partial_t p_t∣ \in L^1([0,1])∣\) then there exists a vector field \(u_t\) of finite length such that \((p_t, u)\) satisfies the continuity equation (see <d-cite key="ambrosio2008gradient"></d-cite> Theorem 8.3.1). For a field \(u\) regular enough such that the initial value problem has a unique solution on \([0,1]\), given \(p_0\), then \((p_t :=f^u(t,⋅)\#p_0, u)\) is a solution to the continuity equation (see <d-cite key="ambrosio2008gradient"></d-cite> Lemma 8.1.6). Note however that the correspondance between \(p_t\) and \(u\) is unique only up to divergence free fields. </span></d-footnote>.</p> <figure> <img class="invert" style="height: 250px" src="/2025/assets/img/2025-04-28-conditional-flow-matching/trifecta.svg" frameborder="0" scrolling="no"> <figcaption class="caption"> Link between the probability path, the velocity field and the flow. </figcaption> </figure> <p>Based on the ODE \eqref{eq:initial_value_pb}, Continuous Normalizing Flows work in the continuous-time domain, and directly model the continuous solution \((x(t))_{t \in [0, 1]}\) instead of a finite number of discretized steps \(x_1, \ldots, x_K\). They do so by learning the velocity field \(u\) as \(u_\theta: \mathbb{R}^d \times [0, 1] \to \mathbb{R}^d\). Sampling is then achieved by solving the initial value problem \eqref{eq:initial_value_pb} with \(x_0\) sampled from the base distribution \(p_0\).</p> <figure class="sidebar" style="--w: 200; --h: 420;"> <video class="invert" style="width: 100%; height: auto; object-fit: cover; border: none;" autoplay="" loop="" muted="" onclick="this.controls = true" src="/2025/assets/img/2025-04-28-conditional-flow-matching/traj.mp4"> </video> </figure> <p>CNFs are a particular case of Neural ODE networks<d-footnote><span>Neural ODE functions are also defined as the solution of an initial value problem like \eqref{eq:initial_value_pb}, but the framework is more general: the loss \(\mathcal{L}\) used for training is arbitrary, and, in order to train \(u_\theta\), the authors provide a way to compute \(\nabla_\theta \mathcal{L}\) by solving an augmented, reversed ODE</span></d-footnote>, with additional tricks to compute the likelihood in order to train them: if \(x(t)\) is the solution of the ODE \eqref{eq:initial_value_pb} with \(u = u_\theta\) , then its log-likelihood \(\log p_t(x(t))\) satisfies the so-called <em>instantaneous change of variable formula</em> <d-cite key="chen2018neural">, derived from the continuity equation:</d-cite></p> \[\begin{equation}\label{eq:ce_logptxt} \frac{\mathrm{d}}{\mathrm{d}t} \log p_t(x(t)) = - \mathrm{tr} J_{u_\theta(\cdot, t)} (x(t)) = - \nabla \cdot u_\theta(\cdot, t)(x(t)) \quad \forall t \in [0, 1] \end{equation}\] <details> <summary>Click here to unroll the proof</summary> <p>The proof relies on the identity</p> \[\nabla\cdot \left( p_t(x) u(t, x) \right) = \langle \nabla p_t(x) , u(x, t) \rangle + p_t(x) \nabla\cdot u(x, t) \, .\] <p>Starting from the continuity equation \eqref{eq:continuity_eq} at any \(t, x\) and dividing it by \(p_t(x)\), we get:</p> \[\begin{align} \frac{1}{p_t(x)} \frac{\mathrm{d} p_t}{\mathrm{d} t}(x) + \frac{1}{p_t(x)} \nabla\cdot(p_t(x) u(x, t)) &amp;= 0 \nonumber \\ \frac{\mathrm{d} \log p_t }{\mathrm{d} t} (x) + \frac{1}{p_t(x)} \langle \nabla p_t(x) , u(x, t) \rangle + \nabla\cdot u(x, t) &amp;= 0 \label{eq:inst_change_pf} \end{align}\] <p>Note that if we plug \(x = x(t)\), the left-hand side is the derivative with respect to \(t\) of \(\log p_t\), evaluated at \(x(t)\). This is different from the derivative with respect to \(t\) of \(t \mapsto \log p_t(x(t))\) – the so-called <em>total derivative</em>, which we now compute:</p> \[\begin{align*} \frac{\mathrm{d} \log p_t(x(t))}{\mathrm{d}t} &amp;= \frac{\mathrm{d} \log p_t }{\mathrm{d} t} (x(t)) + \langle \nabla \log p_t(x(t)), \frac{\mathrm{d}}{\mathrm{d}t} x(t) \rangle \\ &amp;= \frac{\mathrm{d} \log p_t }{\mathrm{d} t} (x(t)) + \langle \frac{1}{p_t(x_t)} \nabla p_t(x(t)), u_\theta(x(t), t) \rangle \\ &amp;= \frac{\mathrm{d} \log p_t }{\mathrm{d} t} (x(t)) + \langle \frac{1}{p_t(x_t)} \nabla p_t(x(t)), u_\theta(x(t), t) \rangle \\ &amp;= - \nabla\cdot u_\theta(x, t) \end{align*}\] <p>using \(\nabla \log p_t(x) = \frac{1}{p_t(x)} \nabla p_t(x)\) and \eqref{eq:inst_change_pf} successively. We conclude by observing that the divergence is equal to the trace of the Jacobian.</p> </details> <p>The ODE \eqref{eq:ce_logptxt} allows evaluating the log-likelihood objective in \eqref{eq:log_lik}, by finding the antecedent by the flow of the data point \(x^{(i)}\) as:</p> \[\begin{equation}\label{eq:inverting_cnf} x(0) = x^{(i)} + \int_1^0 u_\theta(x(t), t) \mathrm{dt} \end{equation}\] <p>(i.e., solving \eqref{eq:initial_value_pb} in reverse), and then<d-footnote><span>Actually, both \(x(0)\) and \(\log p_1(x^{(i)})\) can be computed in one go, by introducing the unknown \(F(t) = \begin{pmatrix} x(t) \\ \log p_t(x(t)) - \log p_1(x(1)) \end{pmatrix}\) and solving the augmented ODE </span> $$ \frac{\mathrm{d}}{\mathrm{d} t} F(t) = \begin{pmatrix} u_\theta(x(t), t) \\ - \nabla\cdot u_\theta(\cdot, t)(x(t)) \end{pmatrix} $$ <span> with initial condition \(F(1) = \begin{pmatrix} x^{(i)} \\ 0 \end{pmatrix}\). Evaluating the solution \(F\) at \(t=0\) gives both \(x(0)\) and \(\log p_0(x(0)) - \log p_1(x^{(i)})\); since \(p_0\) is available in closed form, this yields \(\log p_1(x^{(i)})\).</span></d-footnote> integrating \eqref{eq:ce_logptxt}:</p> \[\log p_1(x^{(i)}) = \log p_0(x(0)) - \int_0^1 \nabla \cdot u_\theta(\cdot, t)(x(t)) \mathrm{dt}\] <p>Finally, computing the gradient of the log-likelihood with respect to the parameters \(\theta\) in \(u_\theta\) is done by solving a reversed and augmented ODE, relying on the adjoint method as in the general Neural ODE framework <d-cite key="grathwohl2018ffjord"></d-cite>.</p> <p>The main benefits of continuous NF are:</p> <ul> <li>the constraints one needs to impose on \(u\) are much less stringent than in the discrete case: for the solution of the ODE to be unique, one only needs \(u\) to be Lipschitz continuous in \(x\) and continuous in \(t\)</li> <li>inverting the flow can be achieved by simply solving the ODE in reverse, starting from \(t=1\) with condition \(x(1) = x^{(i)}\) as in \eqref{eq:inverting_cnf}</li> <li>computing the likelihood does not require inverting the flow, nor to compute a log determinant; only the trace of the Jacobian is required, that can be approximated using the Hutchinson trick<d-footnote><span>The Hutchinson trick is \(\mathop{\mathrm{tr}} A = \mathbb{E}_\varepsilon[\varepsilon^t A \varepsilon]\) for any random variable \(\varepsilon \in \mathbb{R}^d\) having centered, independent components of variance 1. In practice, the expectation is approximated by Monte-Carlo sampling, usually using only one realization of \(\varepsilon\)</span></d-footnote>.</li> </ul> <p>However, training a neural ODE with log-likelihood does not scale well to high-dimensional spaces, and the process tends to be unstable, likely due to numerical approximations and to the (infinite) number of possible probability paths. In contrast, the flow-matching framework, which we now describe, explicitly targets a specific probability path during training. It is a likelihood-free approach, that does not require solving ODE – being hence coined a <em>simulation-free</em> method.</p> <h2 id="conditional-flow-matching">Conditional Flow Matching</h2> <p>This part presents <strong>Conditional Flow Matching</strong> (CFM). While the first part gives interesting background on normalizing flows, it is not a strict requirement to understand the principle of CFM.</p> <p>Before giving the goal and intuition of CFM, we summarize the main concepts and visual representation used in this blog post.</p> <figure> <div class="l-page" style="--ar: calc(218 / 161)"> <iframe style="aspect-ratio: 1; width: calc(100% / ( 1 + 2 * var(--ar)));" src="/2025/assets/html/2025-04-28-conditional-flow-matching/ot-flow-1d.html#loop9" frameborder="0" scrolling="no"></iframe> <img style="vertical-align: top; width: calc(100% * var(--ar) / ( 1 + 2 * var(--ar)));" src="/2025/assets/img/2025-04-28-conditional-flow-matching/pbackground.svg"> <iframe style="aspect-ratio: var(--ar); margin: 0 -5px; width: calc(100% * var(--ar) / ( 1 + 2 * var(--ar)));" src="/2025/assets/html/2025-04-28-conditional-flow-matching/u-anim.html" frameborder="0" scrolling="no"></iframe> </div> <figcaption class="caption"> <p>Three types of visuals used in this blog post.</p> </figcaption> </figure> <div class="boxed"> <p>Core concepts and visuals manipulated in this post</p> <p><span class="ref-lastfig">Figure </span> illustrates the key background elements necessary to understand Flow Matching.</p> <ul> <li> <strong>(left)</strong> A flow that maps a simple distribution \(p_0\) in blue (typically \(\mathcal{N}(0,1)\)) into the data distribution to be modelled \(\pdata\) in red. The probability path \(\p\) associates to each time \(t\), a distribution (dashed).</li> <li> <strong>(center)</strong> The two distributions (in gray) together with a probability path \(\p\) shown as a heatmap. Such a sufficiently regular probability path is governed by a velocity field \(\u\).</li> <li> <strong>(right)</strong> The velocity field \(\u\) (shown with arrows and colors) corresponding to the previous probability path. The animation shows samples from \(p_0\) that follow the velocity field. The distribution of these samples corresponds to \(\p\).</li> </ul> </div> <h3 id="intuition-of-conditional-flow-matching">Intuition of Conditional Flow Matching</h3> <figure class="sidebar is-right" style="--w: 200; --h: 300;"> <iframe style="--h: 147" src="/2025/assets/html/2025-04-28-conditional-flow-matching/u-anim.html" frameborder="0" scrolling="no"></iframe> <figcaption class="caption"> Generation of samples from \(p_1\) can be done by sampling from \(p_0\) and then following the velocity field \(\utheta\). </figcaption> </figure> <p><strong>Goal</strong>. <em>Similarly</em> to continuous normalizing flows, the goal of conditional flow matching is to find a velocity field \(\utheta\) that, when followed/integrated, transforms \(p_0\) into \(\pdata\). Once the velocity field is estimated, the data generation process of conditional flow matching and continuous normalizing flows are the same. It is illustrated in <span class="ref-lastfig">Figure </span>. The <em>particularity of CFM</em> is how the velocity field is learned, as we will detail below.</p> <figure class="sidebar" style="--w: 200; --h: 320;"> <iframe style="--h: 200" src="/2025/assets/html/2025-04-28-conditional-flow-matching/ot-flow-1d.html#loop3" frameborder="0" scrolling="no"></iframe> <figcaption class="caption"> An infinite number of probability paths \((p_t)_{t \in [0,1]}\) that transforms \(p_0\) in \(\pdata\). </figcaption> </figure> <p><strong>Intuition</strong>. In order to make the learning of the velocity field \(\utheta\) easier, one would like to get a supervision signal at each time step \(t \in [0,1]\) (and not only at time \(t=1\)). However, as illustrated in <span class="ref-lastfig">Figure </span>, there exists an infinite number of probability paths \(p_t\) (equivalently an infinite number of velocity fields \(\u\)) that tranform \(p_0\) in \(\pdata\). Thus, in order to get supervision for all \(t\), one must <strong>fully specify a probability path/velocity field</strong>.</p> <p><strong>Organization</strong>. In the <a href="#modelling-choices"> Modelling Choices Section </a> we provide details on how CFM fully specifies a probability path \(p_t\) that transforms \(p_0\) into \(\pdata\): this is not trivial since \(\pdata\) is unknown. Then in the <a href="#from-conditional-to-unconditional-velocity"> From Conditional to Unconditional Velocity Section </a> we provide new intuition on how to interpret the corresponding fully specified velocity field \(\u\). Finally, we recall how CFM learns the velocity field \(\u\) in a tractable fashion. </p> <h3 id="modelling-choices">Modelling Choices</h3> <div class="sidebar" style="--w: 200; --h: 150;"> <div class="caption"> <p>We consider \(t\) as a random variable and interchangeably write \(p(x \| t)\) and \(p_t(x)\).</p> </div> </div> <p><strong>How to fully specify a probability path \(p_t\)?</strong> For unknown target data distribution \(\pdata\) it is hard to choose a priori a probability path or velocity field. CFM core idea is to choose a conditioning variable \(z\) and a conditional probability path \(\pcond\) (examples below) such that (1) the induced global probability path \(\p\) transforms \(p_0\) into \(\pdata\), (2) the associated velocity field \(u^\mathrm{cond}\) has an analytic form.</p> <p><strong>Example 1: Linear interpolation <d-cite key="albergo_building_2023,liu_flow_2023"></d-cite></strong></p> <div class="left-lined"> <p>A first choice is to condition on the base points and the target points, i.e., \(z\) is a random variable defined as:</p> \[\begin{align*} z \overset{\mathrm{choice}}{=} (x_0, x_1) \sim p_0 \times p_\mathrm{data} \, . \end{align*}\] <p>Among all the possible probability paths, one can choose to use very concentrated Gaussian distributions and simply interpolate between \(x_0\) and \(x_1\) in straight line: for some fixed standard deviation \(\sigma\), it writes as</p> \[\begin{align*} p \big (x | t, z=(x_0, x_1) \big) \overset{\mathrm{choice}}{=} \mathcal{N}((1 - t) \cdot x_0 + t \cdot x_1, \sigma^2 \mathrm{Id}) \, . \end{align*}\] <p>To recover the correct distributions \(p_0\) at \(t= 0\) (resp. \(p_\mathrm{target}\) at \(t=1\)), one must enforce \(\sigma = 0\), finally leading to</p> \[\begin{align*} p \big (x | t, z=(x_0, x_1) \big) \overset{\mathrm{choice}}{=} \delta_{ (1-t) \cdot x_0 + t \cdot x_1 } (x) \, , \end{align*}\] <p>where \(\delta\) denotes the Dirac delta distribution.</p> <div class="sidebar" style="--w: 200; --h: 220;"> <div class="caption"> <p>\(t\) will always be a uniform random variable between \(0\) and \(1,\) hence \(p(t)=1\), and \(p(x \| t) = \frac{p(x, t)}{p(t)} = p(x, t)\). Similarly \(\pcond = p(x,t|z)\).</p> </div> </div> <figure class=""> <div style="--r: calc(1250 / (1250 + 400)); display: flex; align-items: end; margin-right: -15px; margin-left: -15px;"> <img style="width: calc(100% * var(--r))" src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_pcondxt_representers.svg"> <video style="width: calc(100% * (1 - var(--r)));border-left:1px solid black" autoplay="" loop="" onclick="this.controls = true" src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_accumulate_pcond.mp4" frameborder="0" scrolling="no"></video> </div> <figcaption class="caption"> <p>Conditional probability paths as linear interpolation.<br> <strong>(left)</strong> \(p(x|t, z=z^{(i)})\) for six samples \(z^{(i)}\) (each being a pair \((x_0,x_1)\)). <strong>(right)</strong> Visualizing the convergence of the empirical average towards \(p(x|t) = \Ebracket{z}{p(x|t,z)} \approx \frac{1}{N} \sum_{i=1}^N p(x|t,z=z^{(i)})\).</p> </figcaption> </figure> <p>Then, one can show that setting</p> \[\ucondcustom{x,t,z = (x_0,x_1)} = x_1 - x_0\] <p>satisfies the continuity equation with \(\pcond\)<d-footnote> In the sense of distributions, one has $$ \begin{align*} &amp; \partial_t p_t (x | t, z) + \nabla \cdot (\ucond p (x|t,z)) \\ =&amp; \langle x_1 - x_0 , \nabla \delta_{ (1-t) \cdot x_0 + t \cdot x_1 }(x) \rangle + \delta_{ (1-t) \cdot x_0 + t \cdot x_1 }(x) \nabla \cdot \ucond + \langle \ucond, \nabla \delta_{ (1-t) \cdot x_0 + t \cdot x_1 }(x) \rangle \end{align*} $$ One can easily identify that \(u(x,t,z) = x_1 - x_0\) which is constant with respect to \(x\) (hence, such that \(\nabla\cdot \ucond = 0 \)) is a suitable solution to the continuity equation.</d-footnote>. Hence, the two choices made – \(z\) and \(p(x |t,z)\) – result in a very easy-to-compute conditional velocity field \(\ucondcustom{x,t,z = (x_0,x_1)}\) which will be later used as a supervision signal to learn \(u_\theta (x,t)\).</p> </div> <p><strong>Example 2: Conical Gaussian paths</strong> <d-cite key="lipman_flow_2023"></d-cite></p> <div class="left-lined"> <p>One can make other choices for the conditioning variable, for instance</p> \[\begin{align*} z \overset{\mathrm{choice}}{=} x_1 \sim \pdata \, , \end{align*}\] <p>and the following choice for the conditional probability path: simply translate and progressively scale down the base normal distribution towards a Dirac delta in \(z\):</p> \[\begin{align*} p(x | t, z=x_1) \overset{\mathrm{choice}}{=} \mathcal{N}(tx_1, (1 - t)^2 \mathrm{Id}) \, . \end{align*}\] <figure class=""> <div style="--r: calc(1250 / (1250 + 400)); display: flex; align-items: end; margin-right: -15px; margin-left: -15px;"> <img style="width: calc(100% * var(--r))" src="/2025/assets/img/2025-04-28-conditional-flow-matching/l/l_pcondxt_representers.svg"> <video style="width: calc(100% * (1 - var(--r)));border-left:1px solid black" autoplay="" loop="" onclick="this.controls = true" src="/2025/assets/img/2025-04-28-conditional-flow-matching/l/l_accumulate_pcond.mp4" frameborder="0" scrolling="no"></video> </div> <figcaption class="caption"> <p>Conditional probability paths as shrinking conical Gaussians.<br> <strong>(left)</strong> \(p(x|t, z=z^{(i)})\) for six samples \(z^{(i)}\) (each being a value \(x_1\)). <strong>(right)</strong> Visualizing the convergence of the empirical average towards \(p(x|t) = \Ebracket{z}{p(x|t,z)} \approx \frac{1}{N} \sum_{i=1}^N p(x|t,z=z^{(i)})\).</p> </figcaption> </figure> <p>Then, one can show that setting \(\ucondcustom{x,t,z = x_1} = \frac{x - x_1}{1 - t}\) leads to a couple \((\ucond, \pcond)\) satisfying the continuity equation.</p> </div> <p><strong>General construction of conditional probability paths</strong></p> <div class="left-lined"> <p>To build a conditional probability path, the user must make two modelling choices:</p> <ul> <li>first, a <strong>conditioning variable</strong> \(z\) (independent of \(t\))</li> <li>then, <strong>conditional probability paths</strong><d-footnote> As Albergo and coauthors <d-cite key="albergo_building_2023"></d-cite>, one can construct the conditional probability path by first defining a conditional flow (also called stochastic interpolant) \(f_t^\mathrm{cond}(x, z)\). By pushing \(p_0\), these flows define random variables \(x \vert t, z = f^\mathrm{cond}(x, t, z)\), which have conditional distributions \(p(\cdot \vert z, t) = f^\mathrm{cond}(\cdot, t, z)\#p_0\).</d-footnote> \(\pcond\) that must satisfy the following constraint: marginalizing \(p(x \vert z, t=0)\) (resp. \(p(x \vert z, t=1)\)) over \(z\), yields \(p_0\) (resp. \(\pdata\)). In other words, \(\pcond\) must satisfy</li> </ul> \[\begin{align*} \forall x \enspace &amp; \Ebracket{z}{ p(x \vert z, t=0) } = p_0(x) \enspace, \\ \forall x \enspace &amp; \Ebracket{z}{ p(x \vert z, t=1) } = \pdata(x) \enspace. \end{align*}\] <details> <summary> Click here to check that the previous examples satisfy these constraints.</summary> <ul> <li>Choice 1:</li> </ul> \[\begin{align*} &amp;z = (x_0, x_1) \sim p_0 \times p_\mathrm{target} \\ &amp;\pcond = \delta_{(1 - t) x_0 + t x_1}(x) \end{align*}\] <p>One also easily checks that \(\int_z p(x \vert z, t=0) p(z) \mathrm{d}z = \int_z \delta_{x_0}(x) p(z) \mathrm{d}z = p_0(x)\) and \(\int_z p(x \vert z, t=1) p(z) \mathrm{d}z = \int_z \delta_{x_1}(x) p(z) \mathrm{d}z = p_\mathrm{target}(x)\)</p> <p>Note that the choice \(p \big (x | t, z=(x_0, x_1) \big) = \mathcal{N}((1 - t) \cdot x_0 + t \cdot x_1, \sigma^2)\), \(\sigma&gt; 0\) does not (exactly) respect the constraint \(\Ebracket{z}{ p(x \vert z, t=0)} = p_0(x)\), but it has been sometimes used in the literature.</p> <ul> <li>Choice 2 (valid for a Gaussian \(p_0\) only):</li> </ul> \[\begin{align*} &amp;z = x_1 \sim p_\mathrm{target} \\ &amp;\pcond = \mathcal{N}(t z, (1 - t)^2 \mathrm{Id}) \end{align*}\] <p>One easily checks that \(\int_z p(x \vert z, t=0) p(z) \mathrm{d}z = \int_z p_0(x) p(z) \mathrm{d}z = p_0(x)\) and \(\int_z p(x \vert z, t=1) p(z) \mathrm{d}z = \int_z \delta_z(x) p(z) \mathrm{d}z = p_\mathrm{target}(x)\), so those are admissible conditional paths.</p> </details> </div> <h3 id="from-conditional-to-unconditional-velocity">From Conditional to Unconditional Velocity</h3> <div class="left-lined"> <p>The previous section provided examples on how to choose a conditioning variable \(z\) and a simple conditional probability path \(\pcond\). The marginalization of \(\pcond\) directly yields a (intractable) closed-form formula for the probability path: \(\p = \Ebracket{z}{\pcond}\).</p> </div> <figure class="l"> <div class="grid-custom1" style=""> <span class="" style="grid-column: 1 / span 3">$$p(x,t|z=z^{(i)})$$</span> <span style="grid-column: 5">$$p(x,t)$$</span> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_pcond_0.svg"> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_pcond_1.svg"> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_pcond_2.svg"> <div style="font-size: 3em;">⇒</div> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_ptot.svg"> <span class="" style="grid-column: 1 / span 3">$$\ucondzi$$</span> <span style="grid-column: 5"></span> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_ucond_0.svg"> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_ucond_1.svg"> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/a/a_ucond_2.svg"> <div style="font-size: 3em;">⇒</div> <div style="font-size: 6em;">?</div> </div> <figcaption class="caption"> <p><strong>(top)</strong> Illustration of conditional probability paths. \(p(x, t | z^{(i)}) = \mathcal{N}((1 - t) \cdot x_0 + t \cdot x_1, \sigma^2)\). <strong>(bottom)</strong> Illustration of the associated conditional velocity fields \(\ucond = x_1 - x_0\) for three different values of \(z =(x_0, x_1)\). <strong>(top right)</strong> By marginalization over \(z\), the conditional probability paths directy yield an expression for the probability path. <strong>(bottom right)</strong> Expressing the velocity field \(\u\) as a function of the conditional velocity field \(\ucond\) is not trivial.</p> </figcaption> </figure> <div class="left-lined"> <p>The conditional probability fields \(\pcond\) have been chosen to have <em>simple/cheap to compute</em> associated conditional velocity field \(\ucond\). In this section we explain how the (intractable) velocity field \(\u\) associated to the probability path \(\p\) can be expressed as an expectation over the (simpler) conditional vector fields \(\ucond\). This challenge is illustrated in <span class="ref-lastfig">Figure </span>. The relationship between \(\p\), \(\pcond\), \(u\), \(\ucond\) is illustrated in <span class="fig-push"></span><span class="ref-lastfig">Fig. </span><span class="fig-pop"></span>.</p> </div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/cfm_uncond_to_cond.svg-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/cfm_uncond_to_cond.svg-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-conditional-flow-matching/cfm_uncond_to_cond.svg-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-conditional-flow-matching/cfm_uncond_to_cond.svg" class="img-fluid invert" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption">For any conditioning variable \(z\), Theorem 1 provides an (intractable) closed-form formula for the unknown velocity field \(u(x ,t)\) as a function of conditional velocity fields \( \ucond \).</figcaption> </figure> <div class="theorem" id="th-uexpect"> <p>Let \(z\) be any random variable independent of \(t\). Choose conditional probability paths \(\pcond\), and let \(\ucond\) be the velocity field associated to these paths.</p> <p>Then the velocity field \(\u\) associated to the probability path<d-footnote><span> recall that \(p(x, t)\) is defined as \(\int_z p(x, t | z)\), i.e., by marginalization over \(z\), and \(u(x, t)\) is an associated velocity field satisfying the continuity equation. </span></d-footnote> \(p(x, t) = \Ebracket{z}{p(x, t | z)}\) has a closed-form formula:</p> \[\begin{align} \forall t, x, \, \, \u &amp;= \Ebracket{z|x, t} {\ucond } \label{eq:condional_flow} \enspace . \end{align}\] </div> <figure class="sidebar" style="--w: 200; --h: 420;"> <div style="position: absolute; left: -1.3em; top: calc(25% - 1em);">$$x$$</div> <div style="position: absolute; top: 35%; left: calc(50% - 0.3em);">$$t$$</div> <iframe style="--h: 200;" class="invert" src="/2025/assets/html/2025-04-28-conditional-flow-matching/cfm-1d.html#inter1" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">Move your mouse at any location \((t, x)\) to see a sampling of \(z | t, x\) (i.e., trajectories between \(x_0\) and \(x_1\) that pass close to \((t,x)\)) and the associated velocity (average of the directions of trajectories)</figcaption> </figure> <details> <summary>Click here to unroll the proof</summary> <p>We first prove an intermediate result, which is the form most often found in the literature, but not the most interpretable in our opinion:</p> \[\begin{align}\label{eq:cond2uncond} \forall \, t, \, x, \, \u = \Ebracket{z}{\frac{\ucond \pcond } {\p}} \enspace. \end{align}\] <details> <summary>Click here to unroll the proof of \eqref{eq:cond2uncond}</summary> \[\begin{aligned} \forall \, t, \, x, \, p(x|t) &amp;= \int_z p(x, z|t) \mathrm{d} z \\ \forall \, t, \, x, \, \partialt{p(x|t)} &amp;= \partialt{} \Ebracket{z}{p(x|t,z)} \\ &amp;= \Ebracket{z}{\partialt{} p(x|t,z)} \quad \small{\text{(under technical conditions)} } \\ &amp;= -\Ebracket{z}{\nabla \cdot \left( \ucond p(x|t,z) \right)} \quad\small{\text{continuity equation for } p(x|t,z)}\\ &amp;= -\nabla \cdot \Ebracket{z}{\ucond p(x|t,z)} \quad \small{\text{(under technical conditions)}} \\ &amp;= -\nabla \cdot \Ebracket{z}{\ucond p(x|t,z) \frac{p(x|t)}{p(x|t)}} \\ &amp;= -\nabla \cdot \left(\Ebracket{z}{\frac{\ucond p(x|t,z)}{p(x|t)}}p(x|t)\right) \quad \small{(p(x|t) \text{ is independent of } z)} \end{aligned}\] <p>Hence \(\forall \, t, \, x, \, \u = \Ebracket{z}{\frac{\ucond \pcond } {\p}}\)</p> <p>satisfies the continuity equation with \(p(x|t)\).</p> </details> <p>Then, we rewrite this intermediate formulation:</p> <p>\(\begin{align} \forall \, t, \, x, \, \u &amp;= \Ebracket{z}{\frac{\ucond \pcond } {\p}} \\ &amp;= \int_z {\frac{\ucond \pcond}{\p}} p(z) \mathrm{d} z \nonumber\\ &amp;= \int_z {\ucond \underbrace{\pcond}_{= \frac{p(z|x, t) \cdot p(x, t)}{p(t, z)}} \cdot p(z) \cdot \underbrace{\frac{1}{\p}}_{= \frac{p(t)}{p(x, t)}} } \mathrm{d} z \nonumber \\ &amp;= \int_z {\ucond \frac{p(z|x, t) \cdot p(x, t)}{p(t, z)} \cdot p(z) \cdot \frac{p(t)}{p(x, t)}} \mathrm{d} z \nonumber \\ &amp;= \int_z {\ucond p(z|x, t) \underbrace{\frac{p(z) \cdot p(t)}{p(t, z)}}_{=1}} \mathrm{d} z \nonumber \\ &amp;= \int_z {\ucond p(z|x, t) } \mathrm{d} z \nonumber \\ &amp;= \Ebracket{z|x, t} {\ucond } \end{align}\)</p> </details> <p><br> <strong>Illustration of Theorem 1</strong> (<span class="ref-lastfig">Figure </span>).</p> <div class="left-lined"> <p>For the choice \(z = (x_0, x_1)\) and \(p(x | t, (x_0, x_1)) = \delta_{(1-t) \cdot x_0 + t \cdot x_1}(x)\), Theorem 1 yields that the velocity field \(\u\) is the mean over \((x_0, x_1)\) of the conditional velocity fields \(\ucond\), going through the point \((t, x)\). This is illustrated in <span class="ref-lastfig">Figure </span>: when you move your mouse on a point \((t, x)\), the red lines are the conditional velocity fields \(\ucond\), going through the point \((t, x)\), and contributing to the velocity field \(\u\) at the point \((t, x)\).</p> </div> <p><strong>Learning with Conditional Velocity Fields</strong>.</p> <div class="left-lined"> <p>We recall that the choices of the conditioning variable \(z\) and the probability paths \(\pcond\) <strong>entirely define the (intractable) vector field \(\u\)</strong>. Conditional flow matching idea is to learn a vector field \(\uthetacfm\) that estimates/”<em>matches</em>” the pre-defined velocity field \(\u\), by regressing against the (cheaper to compute) condition velocity fields \(\ucond\) associated to the conditional probability paths \(\pcond\).</p> </div> <div class="theorem" id="th-lossequiv"> Regressing against the conditional velocity field \(\ucond\) with the following conditional flow matching loss, $$\begin{aligned} \mathcal{L}^{\mathrm{CFM}}(\theta) &amp; \overset{\mathrm{def}}{=} \E{ \substack{t \sim \mathcal{U}([0, 1]) \\ z \sim p_z \\ x \sim p( \cdot | t, z) } }{\lVert \uthetacfm - \underbrace{\ucond}_{\substack{ \text{chosen to be} \\ \text{explictly defined}, \\ \text{cheap to compute}, \\ \text{e.g., } x_1 - x_0}} \rVert^2} \enspace, \end{aligned}$$ is equivalent to directly regressing against the intractable unknown vector field \(\u \) $$\begin{align*} \mathcal{L}^{\mathrm{CFM}}(\theta) &amp; \underset{(\text{proof below})}{=} \E{\substack{ t \sim \mathcal{U}([0, 1]) \\ x \sim p_t} } \Vert{\uthetacfm - \underbrace{\u}_{\substack{\text{implicitly defined,} \\ \text{hard/expensive} \\ \text{to compute}}}}\Vert^2 + \underbrace{C}_{\text{indep. of } \theta} \enspace. \end{align*}$$ </div> <details> <summary>Click here to unroll the proof</summary> \[\begin{aligned} \mathcal{L}^{\mathrm{CFM}}(\theta) &amp; : = \E{(x, t, z)}{\lVert \uthetacfm - \ucond \rVert^2} \\ &amp; = \E{(x, t, z)}[ {\lVert \uthetacfm \rVert^2 - 2\langle \uthetacfm, \ucond \rangle] + \underbrace{\E{(x, t, z)}\lVert \ucond \rVert^2}_{:= C_1 \text{ indep. of } \theta}} \\ &amp; = \E{(x, t, z)}[ {\lVert \uthetacfm \rVert^2 - 2\langle \uthetacfm, \ucond \rangle } ] + C_1 \\ &amp; = \E{(x, t)} \E{(z | x, t)} [ {\lVert \underbrace{\uthetacfm}_{\text{indep. of } z | x, t} \rVert^2 - 2\langle \uthetacfm, \ucond \rangle } ] + C_1 \\ &amp; = \E{(x, t)}[ \lVert \uthetacfm \rVert^2 - { 2\langle \uthetacfm, \underbrace{\E{(z | x, t)} \ucond}_{= \u \, \text{(eq. \eqref{eq:condional_flow})}} \rangle } ] + C_1 \\ &amp; = \E{(x, t)}[ \underbrace{\Vert{\uthetacfm}\Vert^2 - { 2\langle \uthetacfm, \u \rangle } + \Vert{\u}\Vert^2}_{\Vert{\uthetacfm - \u}\Vert^2}] - \underbrace{\E{(x, t)} \Vert{\u}\Vert^2}_{:= C_2 \text{ indep. of }\theta} + C_1 \\ &amp; = \E{(x, t)} \Vert{\uthetacfm - \u}\Vert^2 + C \end{aligned}\] </details> <p>Finally, the loss \(\mathcal{L}^{\mathrm{CFM}}\) can optimized using standard mini-batch gradient techniques. It is easy to sample \((x, t, z)\): \(t\) is uniform, \(x| t, z\) is easy by design of the conditional paths, and the available samples \(x^{(1)}, \ldots, x^{(n)}\) can be used to sample \(z\).</p> <h4 id="summary-flow-matching-in-practice">Summary: Flow Matching In Practice</h4> <table class="summary-table" style="width:100%; border-collapse: collapse;"> <tr style="color: black;"> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center; width: 40%;"><strong>Flow Matching In Practice</strong></td> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center; background-color: #d8e2dc; width: 30%;"><strong>Linear Interpolation</strong></td> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center; background-color: #f0e1f5; width: 30%;"><strong>Conical Gaussian Paths</strong></td> </tr> <tr> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center;"><strong>1. Define a variable \(z\) with some known distribution \(p(z)\)</strong></td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #d8e2dc; text-align: center;">\(p(z = (x_0, x_1)) = p_0 \times \pdata\)</td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #f0e1f5; text-align: center;">\(p(z= x_1) = \pdata\)</td> </tr> <tr> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center;"><strong>2. Define a simple conditional distribution \(p(x \mid t,z)\)</strong></td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #d8e2dc; text-align: center;">\(\mathcal{N}((1-t) \cdot x_0 + t \cdot x_1, \sigma^2 \cdot \mathrm{Id})\)</td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #f0e1f5; text-align: center;">\(\mathcal{N}(t \cdot x_1, (1-t)^2 \cdot \mathrm{Id}) \)</td> </tr> <tr> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center;"><strong>3. Compute an associated velocity field \(\ucond\)</strong></td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #d8e2dc; text-align: center;">\(x_1 - x_0\)</td> <td style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #f0e1f5; text-align: center;">\(\frac{x_1-x}{1-t}\)</td> </tr> <tr> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center;"> <strong>4. Train model using the conditional loss \(\mathcal{L}^{\mathrm{CFM}}\)</strong><br> Sample \(t \sim \mathcal{U}_{[0,1]}\), \(z \sim p_z\), \(x \sim p(x \mid t,z)\) </td> <td colspan="2" style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #bcd9f0; text-align: center;"> Use data points \(x^{(1)}, \ldots, x^{(n)}\) </td> </tr> <tr> <td style="padding: 10px; border-bottom: 1px solid #ddd; text-align: center;"> <strong>5. Sample from \(p_1 \approx \pdata\)</strong><br> Sample \(x_0 \sim p_0\), Integration scheme on \(t \in [0,1]\) </td> <td colspan="2" style="padding: 10px; border-bottom: 1px solid #ddd; background-color: #bcd9f0; text-align: center;"> Numerical integration, e.g, Euler scheme: \(x_{k+1} = x_k + \frac{1}{N} u_\theta(x_k,t)\) </td> </tr> </table> <h2 id="going-further">Going Further</h2> <p>As additional content, we develop two topics: accelerating sampling with CFM, and the links between CFM and diffusion models <d-cite key="peluchetti2023non,shi2024diffusion"></d-cite>.</p> <h3 id="fast-sampling-with-straight-flows">Fast Sampling with Straight Flows</h3> <div class="left-lined"> <p>Moving from Continuous Normalizing Flows to Conditional Flow Matching eliminates the need to solve ODEs during training, hence yields a cheaper and more robust traning procedure. The next step to improve CFM is to <strong>speed up the data generation</strong>, for which solving an ODE is still needed. To this end, a key observation is that the straighter the line is between the base point and the generated sample, the fewer steps can be taken when solving the ODE numerically. Hence some recent efforts put to obtain straight flows while using Flow Matching <d-cite key="pooladian23ot,kornilov2024optimal,tong2024improving"></d-cite>.</p> <p>Consider the case where the conditioning variable is \(z = (x_0, x_1)\). In what precedes we have chosen to use \(p(z = (x_0, x_1)) = p_0 \times p_\mathrm{target}\), but in fact one is free to choose any distribution for \(z\), as long as it is a <em>coupling</em> \(\pi \in \Pi(p_0, p_\mathrm{target})\) <d-footnote> \(\Pi(p_0, p_\mathrm{target})\) denotes the set of probability measures on the product space having marginals \(p_0\) and \(p_\mathrm{target}\). </d-footnote>.</p> <h4 id="rectified-flow-matching">Rectified Flow Matching</h4> <p>A first idea is to start from the simplest example: the independent coupling for \(p(z)\) and the linear interpolation for \(p(x\| t,z)\).</p> <figure class="sidebar" style="--w: 200; --h: 420;"> <div style="position: absolute; left: -1.3em; top: calc(25% - 1em);">$$x$$</div> <div style="position: absolute; top: 35%; left: calc(50% - 0.3em);">$$t$$</div> <iframe style="--h: 200;" class="invert" src="/2025/assets/html/2025-04-28-conditional-flow-matching/cfm-1d.html#inter1" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">Move your mouse at any location \((t, x)\) to see a sampling of \(z | t, x\) (i.e. trajectories between \(x_0\) and \(x_1\) that pass close to \((t,x)\)) and the associated flow direction (average of the directions of trajectories)</figcaption> </figure> <p>Then as in <span class="ref-lastfig">Figure </span>, the lines between the samples \(x_0\) and \(x_1\) cross, and the direction of the velocity field is not straight. Yet, once the model is trained and one generates new samples, one takes a base point and follow \(u_\theta\): this defines a new line between base points and samples. These new trajectories may still not be straight but at least, they do not cross anymore: they can serve as a new coupling for \(z\) to re-start the training procedure, hence <em>rectifying</em> the flow step by step. This is the approach originally proposed by <d-cite key="liu2023flow"></d-cite>.</p> <h4 id="optimal-transport-flow-matching">Optimal Transport Flow Matching</h4> <figure class="sidebar is-right" style="--w: 200; --h: 350;"> <div style="position: absolute; left: -1.3em; top: calc(25% - 1em);">$$x$$</div> <div style="position: absolute; top: 45%; left: calc(50% - 0.3em);">$$t$$</div> <iframe style="--h: 200;" class="invert" src="/2025/assets/html/2025-04-28-conditional-flow-matching/cfm-1d.html#inter2" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">(Move your mouse at any location \((t, x)\)) Same as <span class="fig-pop"></span><span class="ref-lastfig">Fig. </span><span class="fig-push"></span> but with minibatch optimal transport coupling.</figcaption> </figure> <p>Another strategy is to directly start from a different coupling than the independent one. Consider the coupling \(\pi^* \in \Pi(p_0, p_\mathrm{target})\) given by Optimal Transport <d-footnote> $$\pi^* = \mathrm{argmin}_{\pi \in \Pi(p_0, p_\mathrm{target})} \int_{x_0, x_1} ||x_0 -x_1||^2 \pi(x_0, x_1) dx_0 dx_1$$ </d-footnote>, then one property of OT is that the lines between \(x_0\) and \(x_1\) <strong>cannot cross</strong>.</p> <p>In practice, the optimal transport is costly to compute for big datasets (and possible mainly with discrete distributions) so minibatch optimal transport is used instead. As shown in <span class="ref-lastfig">Figure </span> (using minibatches of 10 points for each distribution) trajectories are still crossing but much less often. This approach can be formalized by setting the conditioning variable \(z\) as a pair of two minibatches, one of \(M\) source samples and one of \(M\) (for simplicity) target samples, i.e., \(z \sim (p_0^M, \pdata^M)\).</p> <figure style="text-align: center; margin: 0 auto; background: none; padding: 10px;"> <div style=" display: flex; justify-content: center; align-items: center; background: none; /* No background */ "> <video class="invert" style=" width: 100%; /* Adjust this value for smaller video size */ background: none; /* Transparent background */ " autoplay="" loop="" muted="" onclick="this.controls = true" src="/2025/assets/img/2025-04-28-conditional-flow-matching/ot_euler_2.mp4"> </video> </div> <caption class="caption"> Sampling trajectories with increasing number of Euler steps. Contrary to the Independent coupling, OT Flow Matching achieves good sampling quality with very few Euler steps and the trajectories are straighter. </caption> </figure> </div> <p>Interestingly, one can see diffusion as a special case of flow-matching in the case of an independant coupling \(\pi\) and a Gaussian source distribution. We first recall the forward and reverse-time diffusion process.</p> <h3 id="diffusion-models">Diffusion Models</h3> <div class="left-lined"> <p>In this paragraph (and only in this paragraph), we take the usual diffusion conventions: \(p_0\) denotes the unknown data distribution, and \(T &gt; 0\) is a fixed time. We consider a continuous-time diffusion process \(x(t)\) that starts at \(x_0 \sim p_0\) and evolves over time \(t \in [0, T]\) to reach a distribution \(p_T\) that is close to a known distribution (e.g., Gaussian). We let \(p_t\) denote the distribution of \(x(t)\).</p> <h4 id="foward-diffusion-process">Foward Diffusion Process</h4> <p>The forward diffusion process is described through the following <em>forward SDE</em>:</p> \[\begin{equation}\label{eq:forward_SDE} dx = h(x, t) dt + g(t) dw_t \end{equation}\] <p>where \(h(\cdot, t): \mathbb{R}^d \longrightarrow \mathbb{R}^d\) is the drift coefficient, \(g(t) \in \mathbb{R}\) is the diffusion coefficient, and \(w_t\) is a standard Wiener process. The functions \(h\) and \(g\) may be chosen in various ways, leading to different types of diffusion processes.</p> <p>In the framework of score-based diffusion models, one chooses \(h\), \(g\), and \(T\) such that the diffusion process \(\{x(t)\}_{0 \leq t \leq T}\) approaches some analytically tractable prior distribution \(\pi\) (typically a Gaussian distribution) at time \(T\), i.e., \(p_T \simeq \pi\).</p> <h4 id="reverse-diffusion-process-sampling">Reverse Diffusion Process: Sampling</h4> <p>The reverse diffusion process is described through the following <em>reverse SDE</em>, to be solved backwards in time:</p> \[\begin{equation}\label{eq:reverse_SDE} dx = [h(x, t) -g(t)^2 \nabla \log p_t(x)] dt + g(t) d\bar{w}_t, \end{equation}\] <p>where \(h\) and \(g\) are the same as in the forward SDE and \(\bar{w}\) is a standard Wiener process in the reverse-time direction. The reverse-time SDE results in the same diffusion process \(\{x(t)\}_{0 \leq t \leq T}\) as the forward-time SDE if the initial condition is chosen as \(x(t) \sim p_T\).</p> <p>One might also consider the <em>reverse ODE</em>, which yields a deterministic process with the same marginal densities:</p> \[\begin{equation}\label{eq:reverse_ODE} dx = [h(x, t) -\frac{1}{2}g(t)^2 \nabla \log p_t(x)] dt. \end{equation}\] <p>This is at the core of score-based diffusion generative models: if one can learn \(\nabla \log p_t\), then one can sample from the distribution \(p_0\) by simulating the process \(x(t)\) backwards in time with \eqref{eq:reverse_SDE}. In practice, one approximates \(\nabla \log p_t(x(t))\) with a neural network \(s_\theta(t, x)\), termed a score-based model, so that \(\nabla \log p_t(x) \simeq s_\theta(t, x)\). Refer to <d-cite key="song2021maximum"></d-cite> for details.</p> <p>We now focus on the family of Variance Preserving (VP) SDEs, corresponding to \(g(t) = \sqrt{\beta_t}\) and \(h(x, t) = -\frac{1}{2}\beta_tx\) where \(\beta_t = \beta_{\text{min}} + \frac{t}{T}(\beta_{\text{max}} - \beta_{\text{min}}).\) In this case, the transition density of the diffusion process is given by</p> \[\begin{equation} p_t(\cdot | x_0=x) = \mathcal{N}(x e^{-\frac{1}{2}\int_{0}^{t} \beta(s) ds}, (1 - e^{-\int_{0}^{t} \beta(s) ds})\mathrm{Id}_d). \end{equation}\] <h3 id="link-between-diffusion-and-flow-matching">Link Between Diffusion and Flow-Matching</h3> <p>To make the link between diffusion and flow-matching, we first assume that \(T = 1\) and that \(\beta_{\text{max}}\) is large enough so that \(e^{-\frac{1}{2}\int_{0}^{1} \beta(s) ds} \simeq 0\). In other words, we assume that the diffusion process approaches a Gaussian distribution well at time 1. We also assume that the source (or latent) distribution in the flow-matching process is Gaussian.</p> <p>A natural question is: <em>When does the reverse ODE process \eqref{eq:reverse_ODE} match the flow-matching ODE?</em></p> <p>Let \(p_0\) denote the latent Gaussian distribution and \(p_1\) the data distribution. The flow-matching ODE is given by</p> \[\begin{equation} \dot{x}(t) = v_\theta(x(t), t),\quad x(0) = x_0, \end{equation}\] <p>where \(v_\theta: [0,1]\times \mathbb{R}^d \longrightarrow \mathbb{R}^d\) is the velocity field to be learned. Let \(\pi\) denote the independent coupling between \(p_0\) and \(p_1\), and let \((X_0, X_1) \sim \pi\). The target probability path in the Conditional Flow Matching loss corresponds to the distribution of the random variable \(X_t\) defined by</p> \[\begin{equation} X_t := a_tX_1 + b_tX_0, \end{equation}\] <p>where \(a : [0,1] \longrightarrow \mathbb{R}\) and \(b : [0,1] \longrightarrow \mathbb{R}\) are fixed parameters. Ideally, to have a proper flow between \(p_0\) and \(p_1\), we would need to have \(a_0 = 0\), \(b_0 = 1\), \(a_1 = 1\), \(b_1 = 0\).</p> <figure class="sidebar is-right" style="--w: 200; --h: 420;"> <div style="position: absolute; left: -1.3em; top: calc(25% - 1em);">$$x$$</div> <div style="position: absolute; top: 35%; left: calc(50% - 0.3em);">$$t$$</div> <iframe style="--h: 200;" class="invert" src="/2025/assets/html/2025-04-28-conditional-flow-matching/cfm-1d.html#inter3" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">Case of diffusion paths. Move your mouse at any location \((t, x)\) to see a sampling of \(z | t, x\) (i.e. trajectories between \(x_0\) and \(x_1\) that pass close to \((t,x)\)) and the associated flow direction (average of the directions of trajectories)</figcaption> </figure> <div class="theorem" id="th-lossequiv"> <p>If \(a_t:= e^{-\frac{1}{2} \int_{0}^{1-t} \beta(s) ds}\) and \(b_t:= \sqrt{1 - e^{-\int_{0}^{1-t} \beta(s) ds}}\), then the flow-matching ODE is equivalent to the reverse ODE \eqref{eq:reverse_ODE} in the VP setting.</p> </div> <details> <summary>Click here to unroll the proof</summary> <p>We show that the optimal velocity field \(v_\theta\) satisfies \(- v_\theta(x(t), 1-t)= h(x(t), t) - \frac{1}{2} g(t)^2 \nabla \log p_t(x(t))\), which means that solving the (forward) flow matching ODE is equivalent to solving the reverse ODE \eqref{eq:reverse_ODE}.</p> <p>According to the Proposition 1 in <d-cite key="zhang2024flow"></d-cite>, the optimal velocity field is given by</p> \[\begin{align*} v_\theta(x(t), 1-t) &amp;= \mathbb{E}[\dot{a}_{1-t} X_1 + \dot{b}_{1-t} X_0 | X_t = x(t)] \nonumber \\ &amp;= \frac{\dot{a}_{1-t}}{a_{1-t}} \left[x(t) + b_{1-t}^2 \nabla \log p_t(x(t))\right] - \dot{b}_{1-t} b_{1-t} \nabla \log p_t(x(t)). \end{align*}\] <p>We have that</p> \[\begin{align*} \dot{a}_{1-t} &amp;= \frac{1}{2} \beta_t e^{-\frac{1}{2} \int_{0}^{t} \beta(s) ds} \\ \dot{b}_{1-t} &amp;= - \frac{1}{2} \beta_t \frac{e^{-\int_{0}^{t} \beta(s) ds}}{\sqrt{1 - e^{-\int_{0}^{t} \beta(s) ds}}} . \end{align*}\] <p>Therefore,</p> \[\begin{align*} \frac{\dot{a}_{1-t}}{a_{1-t}} &amp;= \frac{1}{2} \beta_t \\ \dot{b}_{1-t} b_{1-t} &amp;= - \frac{1}{2} \beta_t e^{-\int_{0}^{t} \beta(s) ds} \end{align*}\] <p>Then</p> \[\begin{align*} v_\theta(x(t), 1-t) &amp;= \frac{1}{2} \beta_t \left[x(t) + \left(1 - e^{-\int_{0}^{t} \beta(s) ds}\right) \nabla \log p_t(x(t))\right] + \frac{1}{2} \beta_t e^{-\int_{0}^{t} \beta(s) ds} \nabla \log p_t(x(t)) \nonumber \\ &amp;= \frac{1}{2} \beta_t x(t) +\frac{1}{2} \beta_t \nabla \log p_t(x(t)). \end{align*}\] <p>Thus, going back to the definitions of \(h\) and \(g\), we have</p> <p>\(\begin{equation} -v_\theta(x(t), 1-t) = h(x(t), t) - \frac{1}{2} g(t)^2 \nabla \log p_t(x(t)), \end{equation}\) which concludes the proof.</p> </details> </div> <h3 id="cfm-playground">CFM Playground</h3> <script data-api="https://track.heeere.com/api/event" data-domain="cfm">!function(){"use strict";function t(t,e){t&&console.warn("Ignoring Event: "+t),e&&e.callback&&e.callback()}function e(e,i){if(/^localhost$|^127(\.[0-9]+){0,2}\.[0-9]+$|^\[::1?\]$/.test(n.hostname)||"file:"===n.protocol)return t("localhost",i);if((window._phantom||window.__nightmare||window.navigator.webdriver||window.Cypress)&&!window.__plausible)return t(null,i);try{if("true"===window.localStorage.plausible_ignore)return t("localStorage flag",i)}catch(e){}var l={},s=(l.n=e,l.u=n.href,l.d=o.getAttribute("data-domain"),l.r=a.referrer||null,i&&i.meta&&(l.m=JSON.stringify(i.meta)),i&&i.props&&(l.p=i.props),new XMLHttpRequest);s.open("POST",r,!0),s.setRequestHeader("Content-Type","text/plain"),s.send(JSON.stringify(l)),s.onreadystatechange=function(){4===s.readyState&&i&&i.callback&&i.callback({status:s.status})}}function i(){s!==n.pathname&&(s=n.pathname,e("pageview"))}var n=window.location,a=window.document,o=a.currentScript,r=o.getAttribute("data-api")||new URL(o.src).origin+"/api/event",l=window.plausible&&window.plausible.q||[];window.plausible=e;for(var s,p=0;p<l.length;p++)e.apply(this,l[p]);var c,u=window.history;u.pushState&&(c=u.pushState,u.pushState=function(){c.apply(this,arguments),i()},window.addEventListener("popstate",i)),"prerender"===a.visibilityState?a.addEventListener("visibilitychange",function(){s||"visible"!==a.visibilityState||i()}):i()}();</script> <figure class=""> <iframe style="--w: 800; --h: 600; width: 100%; background: white;" class="invert" src="/2025/assets/html/2025-04-28-conditional-flow-matching/cfm-1d.html#playground" frameborder="0" scrolling="no"></iframe> <figcaption class="caption">A playground to explore a variety of CFM settings.</figcaption> </figure> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/2025/assets/bibliography/2025-04-28-conditional-flow-matching.bib"></d-bibliography> <d-article id="bibtex-container" class="related highlight"> For attribution in academic contexts, please cite this work as <pre id="bibtex-academic-attribution">
        PLACEHOLDER FOR ACADEMIC ATTRIBUTION
  </pre> BibTeX citation <pre id="bibtex-box">
        PLACEHOLDER FOR BIBTEX
  </pre> </d-article> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2025" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>