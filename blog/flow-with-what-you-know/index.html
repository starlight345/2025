<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <script>let thunk=()=>{let e=e=>e.trim(),t=e=>e.innerText,n=e=>{let t=e.split(" "),n=t.slice(0,-1).join(" ");return[t.at(-1),n]},i=Array.from(document.getElementsByClassName("author")).map(t).map(e).map(n),a=i[0][0],o=(Array.from(document.getElementsByClassName("affiliation")).filter(e=>"P"===e.nodeName).map(t).map(e),"April 28, 2025"),r="Flow With What You Know",l="This tutorial provides an accessible introduction to flow-matching and rectified flow models, which are increasingly at the forefront of generative AI applications. Typical descriptions of them are often laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly accessible (yet functionally equivalent) representation of the processes involved.";{let e=i.map(e=>`${e[0]}, ${e[1]}`).join(" and "),t=`\n@inproceedings{${(a+"2025"+r.split(" ").slice(0,3).join("")).replace(" ","").replace(/[\p{P}$+<=>^`|~]/gu,"").toLowerCase().trim()},\n  author = {${e}},\n  title = {${r}},\n  abstract = {${l}},\n  booktitle = {ICLR Blogposts 2025},\n  year = {2025},\n  date = {${o}},\n  note = {${window.location.href}},\n  url  = {${window.location.href}}\n}\n  `.trim();document.getElementById("bibtex-box").innerText=t}{let e=i.map(e=>e[0]),t=`\n${e=e.length>2?e[0]+", et al.":2==e.length?e[0]+" & "+e[1]:e[0]}, "${r}", ICLR Blogposts, 2025.\n`.trim();document.getElementById("bibtex-academic-attribution").innerText=t}};document.addEventListener("readystatechange",function(){"complete"===document.readyState&&thunk()});</script> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Flow With What You Know | ICLR Blogposts 2025</title> <meta name="author" content="ICLR Blog"> <meta name="description" content="This tutorial provides an accessible introduction to flow-matching and rectified flow models, which are increasingly at the forefront of generative AI applications. Typical descriptions of them are often laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly accessible (yet functionally equivalent) representation of the processes involved."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2025/assets/img/iclr_favicon.ico"> <link rel="stylesheet" href="/2025/assets/css/main.css"> <link rel="canonical" href="https://starlight345.github.io/2025/blog/flow-with-what-you-know/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/2025/assets/js/theme.js"></script> <script src="/2025/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/2025/assets/js/distillpub/template.v2.js"></script> <script src="/2025/assets/js/distillpub/transforms.v2.js"></script> <script src="/2025/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}.mycodeblock{color:#429472}img.animated-gif{height:250px;width:auto}a{color:#87cefa}a:hover{color:#1e90ff}.callout-block{width:85%;margin:25px auto;padding:15px 30px;background-color:#1f2937;color:#f3f4f6;border-radius:8px}</style> <d-front-matter> <script async type="text/json">{
      "title": "Flow With What You Know",
      "description": "This tutorial provides an accessible introduction to flow-matching and rectified flow models, which are increasingly at the forefront of generative AI applications. Typical descriptions of them are often laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly accessible (yet functionally equivalent) representation of the processes involved.",
      "published": "April 28, 2025",
      "authors": [
        {
          "author": "Scott H. Hawley",
          "authorURL": "https://hedges.belmont.edu",
          "affiliations": [
            {
              "name": "Belmont University and Hyperstate Music, Inc.",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> </head> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2025/">ICLR Blogposts 2025</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2025/about/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/call/">call for blogposts</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/submitting/">submitting</a> </li> <li class="nav-item "> <a class="nav-link" href="/2025/reviewing/">reviewing</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2025/" rel="external nofollow noopener noopener noreferrer" target="_blank"><strong>2025</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2024/" rel="external nofollow noopener noopener noreferrer" target="_blank">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2023/" rel="external nofollow noopener noopener noreferrer" target="_blank">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener noopener noreferrer" target="_blank">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Flow With What You Know</h1> <p>This tutorial provides an accessible introduction to flow-matching and rectified flow models, which are increasingly at the forefront of generative AI applications. Typical descriptions of them are often laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly accessible (yet functionally equivalent) representation of the processes involved.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#introduction">Introduction</a></div> <ul> <li><a href="#what-s-a-flow">What's a Flow?</a></li> </ul> <div><a href="#how-do-fm-rf-models-work">How Do FM/RF Models Work?</a></div> <ul> <li><a href="#the-starting-setup">The Starting Setup</a></li> <li><a href="#how-are-flows-learned">How Are Flows Learned?</a></li> <li><a href="#training-code">Training Code</a></li> </ul> <div><a href="#reflow-to-go-straighter-faster">Reflow to Go Straighter &amp; Faster</a></div> <ul> <li><a href="#upgrading-our-gear-first">Upgrading Our Gear First</a></li> <li><a href="#learning-to-reflow">Learning to Reflow</a></li> </ul> <div><a href="#connecting-with-other-models">Connecting With Other Models</a></div> <ul> <li><a href="#from-dots-to-images-audio-etc">From Dots to Images, Audio, etc.</a></li> <li><a href="#diffusion-models">Diffusion Models</a></li> <li><a href="#optimal-transport">Optimal Transport</a></li> <li><a href="#normalizing-flows">Normalizing Flows</a></li> </ul> <div><a href="#summary">Summary</a></div> </nav> </d-contents> <h1 id="introduction">Introduction</h1> <p>Flow-based generative AI models <d-cite key="lipman2023flow"></d-cite>,<d-cite key="rectified_flow"></d-cite> have been gaining significant traction as alternatives or improvements to traditional diffusion approaches in image and audio synthesis. These flow models excel at learning optimal trajectories for transforming probability distributions, offering a mathematically elegant framework for data generation. The approach has seen renewed momentum following Black Forest Labs’ success with their FLUX models <d-cite key="flux_paper"></d-cite>, spurring fresh interest in the theoretical foundations laid by earlier work on Rectified Flows <d-cite key="rectified_flow"></d-cite> in ICLR 2023. Subsequent improvements <d-cite key="improving_rf"></d-cite> have even reached the level of state-of-the-art generative models for one or two-step generation.</p> <p>Intuitively, these models operate akin to the fluid processes that transform the shapes of clouds in the sky. While recent expositions <d-cite key="mathieu2024flow"></d-cite>,<d-cite key="jia_bin"></d-cite> have attempted to make these concepts more accessible through probability theory, the underlying physical principles may offer a more direct path to understanding for many readers. By returning to the basic physical picture of flows that inspired these generative models, we can build both intuition and deep understanding - insights that may even guide the development of new approaches.</p> <h2 id="whats-a-flow">What’s a Flow?</h2> <p>In the real world, things typically follow curved paths - like water flowing in a river, or crowds of people navigating around obstacles. Here’s map of wind provided from the <a href="http://ww2010.atmos.uiuc.edu/%28Gh%29/guides/maps/fcst/3wndhght.rxml" rel="external nofollow noopener noopener noreferrer" target="_blank">WW2010 atmospheric science project at UIUC</a>: at every point in space, the wind has a velocity vector, and the air moves along “streamlines” or “trajectories” parallel to the velocity vectors…</p> <div class="l-page"> <center> <iframe src="/2025/assets/img/2025-04-28-flow-with-what-you-know/weather-map.gif" frameborder="0" scrolling="no" height="300px" width="500"></iframe><br> <i>Source: <a href="http://ww2010.atmos.uiuc.edu/%28Gh%29/guides/maps/fcst/3wndhght.rxml" rel="external nofollow noopener noopener noreferrer" target="_blank">atmos.uiuc.edu</a></i> </center> </div> <p>Notice that the streamlines never cross. If the streams were to cross… “it would be bad.” <d-footnote>"Don't cross the streams." -- Ghostbusters (1984)</d-footnote> That would imply that the velocity at some point is undefined.</p> <div class="callout-block"> <b>Note:</b> This non-crossing property is what allows these flows to be invertible (i.e., reversible), a property you sometimes hear in isolation when reading more formal descriptions of flow models. </div> <p>So, at every point in space there’s a velocity vector telling the little bits of fluid where to go. And just like water or wind flows may depend not only on spatial position but also time, so too can our velocity vector field depend on position and time.</p> <p>Flow matching learns these natural paths by focusing on the <em>velocity</em> at each point - essentially asking, “Which way should each data point be moving at this moment?”</p> <div class="callout-block"> <b>Terminology: "FM/RF", "Rectified"</b><br> It may seem confusing to see "flow matching" and "rectified flows" sometimes used interchangeably, but this is because <b><i>they are the same</i></b><d-cite key="tanishq_same"></d-cite>. In this blog post, we'll use the collective term "FM/RF" models.<br> Also, note that <b><i>there is no explicit "rectification" mechanism</i></b> in rectified flows; rather, "rectified" is a description of the effect of flow-matching, i.e., of transforming crossing trajectories to non-crossing ones. The addition of "Reflow" to the rectified flow paper<d-cite key="rectified_flow"></d-cite> is a powerful extension we will cover further below. </div> <h1 id="how-do-fmrf-models-work">How Do FM/RF Models Work?</h1> <p>To gain a deep understanding of how models work, having an executable toy model is often a key instructional tool. This tutorial is written as an executable Jupyter notebook<d-footnote>Colab link: <a href="https://tinyurl.com/iclr-2025-flow-blogpost-colab" rel="external nofollow noopener noopener noreferrer" target="_blank">https://tinyurl.com/iclr-2025-flow-blogpost-colab</a></d-footnote>, though you can make sense of it without the code, so we will typically collapse or hide the code. But if you want to see it, you can expand the drop-down arrows.</p> <p>For instance, the code starts with importing packages…</p> <details> <summary class="mycodeblock">Show code: Installs &amp; imports</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Uncomment to install any missing dependencies:
#%pip install torch numpy matplotlib tqdm plotly
</span>    
<span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>  
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="n">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">clear_output</span>
<span class="kn">from</span> <span class="n">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="n">plotly.graph_objects</span> <span class="k">as</span> <span class="n">go</span></code></pre></figure> </details> <p><strong>Choose Your Own Data Shapes</strong></p> <p>The <a href="https://colab.research.google.com/drive/1LfFgfvykgZOi9fcduE_Zkt1QYJxPKNtx?usp=sharing" rel="external nofollow noopener noopener noreferrer" target="_blank">executable notebook verison of this lesson</a> lets you choose various shapes to “morph” between. For this reading, we’ll go from a Gaussian to a Spiral, but other choices are available in the notebook.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Options are: 'Gaussian', 'Square', 'Heart', 'Spiral','Two Gaussians', 'Smiley'
</span><span class="n">source_data_choice</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Gaussian</span><span class="sh">'</span>
<span class="n">target_data_choice</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Spiral</span><span class="sh">'</span>  </code></pre></figure> <div class="callout-block"> <b>Note:</b> Flow models don't require gaussian prior distributions. You can choose whatever you want. </div> <p>With the imports in place and the choice of starting and ending distributions made, we’re ready to define some utilities to generate and visualize our data. Let’s take a look:</p> <details> <summary class="mycodeblock">Show code: Utilities, styles, functions, generators, visualization</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># for accessibility: Wong's color pallette: cf. https://davidmathlogic.com/colorblind
#wong_black = [0/255, 0/255, 0/255]          # #000000
</span><span class="n">wong_amber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">230</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">159</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>      <span class="c1"># #E69F00
</span><span class="n">wong_cyan</span> <span class="o">=</span> <span class="p">[</span><span class="mi">86</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">180</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">233</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>      <span class="c1"># #56B4E9
</span><span class="n">wong_green</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">158</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">115</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>      <span class="c1"># #009E73
</span><span class="n">wong_yellow</span> <span class="o">=</span> <span class="p">[</span><span class="mi">240</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">228</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">66</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>    <span class="c1"># #F0E442
</span><span class="n">wong_navy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">114</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">178</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>       <span class="c1"># #0072B2
</span><span class="n">wong_red</span> <span class="o">=</span> <span class="p">[</span><span class="mi">213</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">94</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>         <span class="c1"># #D55E00
</span><span class="n">wong_pink</span> <span class="o">=</span> <span class="p">[</span><span class="mi">204</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">121</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">167</span><span class="o">/</span><span class="mi">255</span><span class="p">]</span>     <span class="c1"># #CC79A7
</span><span class="n">wong_cmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">wong_amber</span><span class="p">,</span> <span class="n">wong_cyan</span><span class="p">,</span> <span class="n">wong_green</span><span class="p">,</span> <span class="n">wong_yellow</span><span class="p">,</span> <span class="n">wong_navy</span><span class="p">,</span> <span class="n">wong_red</span><span class="p">,</span> <span class="n">wong_pink</span><span class="p">]</span>

<span class="n">source_color</span> <span class="o">=</span> <span class="n">wong_navy</span>
<span class="n">target_color</span> <span class="o">=</span> <span class="n">wong_red</span>
<span class="n">pred_color</span> <span class="o">=</span> <span class="n">wong_green</span>
<span class="n">line_color</span> <span class="o">=</span> <span class="n">wong_yellow</span>
<span class="n">bg_theme</span> <span class="o">=</span> <span class="sh">'</span><span class="s">dark</span><span class="sh">'</span> <span class="c1">#  'black', 'white', 'dark', 'light'
</span><span class="k">if</span> <span class="n">bg_theme</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">dark</span><span class="sh">'</span><span class="p">]:</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">style</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="sh">'</span><span class="s">dark_background</span><span class="sh">'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">rcdefaults</span><span class="p">()</span>
    

<span class="c1"># A few different data distributions
</span><span class="k">def</span> <span class="nf">create_gaussian_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a 2D Gaussian distribution</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>

<span class="k">def</span> <span class="nf">create_square_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>  <span class="c1"># 3 is set by the spread of the gaussian and spiral 
</span>    <span class="sh">"""</span><span class="s">Create points uniformly distributed in a square</span><span class="sh">"""</span>
    <span class="c1"># Generate uniform points in a square
</span>    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="k">return</span> <span class="n">points</span>
 
<span class="k">def</span> <span class="nf">create_spiral_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a spiral distribution. i like this one more</span><span class="sh">"""</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">scale</span> 
    <span class="c1">#theta = torch.linspace(0, 6*np.pi, n_points) # preferred order? no way
</span>    <span class="n">theta</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">create_heart_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a heart-shaped distribution of points</span><span class="sh">"""</span>
    <span class="n">square_points</span> <span class="o">=</span> <span class="nf">create_square_data</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    
    <span class="c1"># Calculate the heart-shaped condition for each point
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">square_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">square_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">heart_condition</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    
    <span class="c1"># Filter out points that don't satisfy the heart-shaped condition
</span>    <span class="n">heart_points</span> <span class="o">=</span> <span class="n">square_points</span><span class="p">[</span><span class="n">heart_condition</span><span class="p">]</span>
    
    <span class="c1"># If we don't have enough points, generate more
</span>    <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">heart_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_points</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="nf">create_square_data</span><span class="p">(</span><span class="n">n_points</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">heart_points</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">new_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_heart_condition</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="n">new_heart_points</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[</span><span class="n">new_heart_condition</span><span class="p">]</span>
        <span class="n">heart_points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">heart_points</span><span class="p">,</span> <span class="n">new_heart_points</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">heart_points</span> <span class="o">*=</span> <span class="n">scale</span> 
    <span class="k">return</span> <span class="n">heart_points</span><span class="p">[:</span><span class="n">n_points</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">create_two_gaussians_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a 2D Gaussian distribution</span><span class="sh">"""</span>
    <span class="n">g</span>  <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">g</span><span class="p">[:</span><span class="n">n_points</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shift</span>
    <span class="n">g</span><span class="p">[</span><span class="n">n_points</span><span class="o">//</span><span class="mi">2</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shift</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randperm</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">create_smiley_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sh">"</span><span class="s">make a smiley face</span><span class="sh">"</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Face circle
</span>    <span class="c1">#angles = 2 * np.pi * torch.rand(n_points//2+20)
</span>    <span class="c1">#r = scale + (scale/10)*torch.sqrt(torch.rand(n_points//2+20)) 
</span>    <span class="c1">#points.append(torch.stack([r * torch.cos(angles), r * torch.sin(angles)], dim=1))
</span>    
    <span class="c1"># Eyes (small circles at fixed positions)
</span>    <span class="k">for</span> <span class="n">eye_pos</span> <span class="ow">in</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]]:</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n_points</span><span class="o">//</span><span class="mi">3</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.2</span> <span class="o">+</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">eye_pos</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="mf">0.4</span>
        <span class="n">points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">eye</span><span class="p">)</span>
        
    <span class="c1"># Smile (arc in polar coordinates)
</span>    <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">n_points</span><span class="o">//</span><span class="mi">3</span><span class="o">+</span><span class="mi">20</span><span class="p">)</span> 
    <span class="n">r_smile</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">+</span> <span class="p">(</span><span class="n">scale</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">r_smile</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r_smile</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># concatenate first
</span>    <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="nf">randperm</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>  <span class="c1"># then shuffle
</span>    <span class="k">return</span> <span class="n">points</span><span class="p">[:</span><span class="n">n_points</span><span class="p">,:]</span>
    

<span class="c1"># Initialize generator functions
</span><span class="n">source_gen_fn</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">target_gen_fn</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># Assign generator functions based on user choices
</span><span class="k">for</span> <span class="n">gen_choice</span><span class="p">,</span> <span class="n">gen_fn_name</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">([</span><span class="n">source_data_choice</span><span class="p">,</span> <span class="n">target_data_choice</span><span class="p">],</span> <span class="p">[</span><span class="sh">'</span><span class="s">source_gen_fn</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">target_gen_fn</span><span class="sh">'</span><span class="p">]):</span>
    <span class="n">gen_choice</span> <span class="o">=</span> <span class="n">gen_choice</span><span class="p">.</span><span class="nf">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="sh">'</span><span class="s">two gaussians</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">gen_choice</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_two_gaussians_data</span>
    <span class="k">elif</span> <span class="sh">'</span><span class="s">heart</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">gen_choice</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_heart_data</span>
    <span class="k">elif</span> <span class="sh">'</span><span class="s">spiral</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">gen_choice</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_spiral_data</span>
    <span class="k">elif</span> <span class="sh">'</span><span class="s">square</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">gen_choice</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_square_data</span>
    <span class="k">elif</span> <span class="sh">'</span><span class="s">smiley</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">gen_choice</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_smiley_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen_fn</span> <span class="o">=</span> <span class="n">create_gaussian_data</span>
    
    <span class="k">if</span> <span class="n">gen_fn_name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">source_gen_fn</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">source_gen_fn</span> <span class="o">=</span> <span class="n">gen_fn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_gen_fn</span> <span class="o">=</span> <span class="n">gen_fn</span>
        
<span class="c1"># A couple aliases so we can easily switch distributions without affecting later code 
</span><span class="k">def</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">hshift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>  <span class="c1"># hshift can make it a bit easier to see trajectories later
</span>    <span class="n">g</span> <span class="o">=</span> <span class="nf">source_gen_fn</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hshift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">g</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hshift</span>
    <span class="k">return</span> <span class="n">g</span>
    
<span class="k">def</span> <span class="nf">create_target_data</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">hshift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nf">target_gen_fn</span><span class="p">(</span><span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hshift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">g</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hshift</span>
    <span class="k">return</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">plot_distributions</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">title1</span><span class="o">=</span><span class="sh">"</span><span class="s">Distribution 1</span><span class="sh">"</span><span class="p">,</span> <span class="n">title2</span><span class="o">=</span><span class="sh">"</span><span class="s">Distribution 2</span><span class="sh">"</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Plot two distributions side by side</span><span class="sh">"""</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">(</span><span class="sh">'</span><span class="s">all</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    
    <span class="n">ax1</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">dist1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dist1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">source_color</span><span class="p">)</span>
    <span class="n">ax2</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">dist2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dist2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">target_color</span><span class="p">)</span>
    
    <span class="n">ax1</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="n">title1</span><span class="p">)</span>
    <span class="n">ax2</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="n">title2</span><span class="p">)</span>
    
    <span class="c1"># Set same scale for both plots
</span>    <span class="n">max_range</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
        <span class="nf">abs</span><span class="p">(</span><span class="n">dist1</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">(),</span>
        <span class="nf">abs</span><span class="p">(</span><span class="n">dist2</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">]:</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        
    <span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>  <span class="c1"># Explicitly show the plot
</span>    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>



<span class="k">def</span> <span class="nf">interpolate_color</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Interpolate from matplotlib</span><span class="sh">'</span><span class="s">s default green (t=0) to red (t=1)</span><span class="sh">"""</span>
    <span class="n">start_color</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_rgb</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end_color</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_rgb</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
    <span class="nf">return </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">start_color</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">end_color</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">show_flow_sequence</span><span class="p">(</span><span class="n">start_dist</span><span class="p">,</span> <span class="n">end_dist</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c_start</span><span class="o">=</span><span class="n">source_color</span><span class="p">,</span> <span class="n">c_end</span><span class="o">=</span><span class="n">target_color</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Show the flow as a sequence of static plots</span><span class="sh">"""</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n_steps</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    
    <span class="n">max_range</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
        <span class="nf">abs</span><span class="p">(</span><span class="n">start_dist</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">(),</span>
        <span class="nf">abs</span><span class="p">(</span><span class="n">end_dist</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">()</span>
    <span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">start_dist</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_dist</span> <span class="o">*</span> <span class="n">t</span>
        
        <span class="n">color</span> <span class="o">=</span> <span class="nf">interpolate_color</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">c_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">c_end</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">current</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">current</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> 
                  <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                  <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">])</span>
        
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">t = </span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>


<span class="c1"># Create our distributions and look at them
</span><span class="n">n_points</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">n_points</span><span class="p">),</span> <span class="nf">create_target_data</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>

<span class="nf">plot_distributions</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="sh">"</span><span class="s">Starting Distribution</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Target Distribution</span><span class="sh">"</span><span class="p">)</span></code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/big_gaussian_and_spiral-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/big_gaussian_and_spiral-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/big_gaussian_and_spiral-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/big_gaussian_and_spiral.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>The process of transitioning from the starting “source” to the final “target” might include snapshots like these:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/transition_frames_example-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/transition_frames_example-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/transition_frames_example-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/transition_frames_example.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>(Note the colors aren’t meaningful, they’re just added to make it easier to distinguish what we’re looking at. Our data are just points in 2-D space.)</p> <p>So, how do we get the points from the source distribution to fit with the target distribution? The simplest way (though not the only way) is to assume points move in straight lines from source to target. Even though our network might learn more complex paths later, this gives us a starting point for training.</p> <h2 id="the-starting-setup">The Starting Setup</h2> <p>The training setup for flow matching models is as follows:</p> <ol> <li>We start by <em>randomly pairing</em> points from the source &amp; the target – yes, really. 🤣</li> <li>We move the points along straight trajectories, and the speed of each point is constant.</li> </ol> <details> <summary class="mycodeblock">Show code: Make 2D flow-matching diagram with crossing lines</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">source_L</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
<span class="n">shift</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">source_L</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shift</span>
<span class="n">target_R</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
<span class="n">target_R</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shift</span>  <span class="c1"># Note: fixed the indexing here from [:0] to [:,0]
</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c1"># show the whole distribution
</span><span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">source_L</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">source_L</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">source_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">target_R</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_R</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">target_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Draw lines connecting points, with source &amp; target points outlined
</span><span class="n">n_lines</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">source_L</span><span class="p">[:</span><span class="n">n_lines</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">source_L</span><span class="p">[:</span><span class="n">n_lines</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">source_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
           <span class="n">facecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">line_color</span><span class="p">,)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">target_R</span><span class="p">[:</span><span class="n">n_lines</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_R</span><span class="p">[:</span><span class="n">n_lines</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">target_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">facecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">line_color</span><span class="p">,)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_lines</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">source_L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> 
        <span class="p">[</span><span class="n">source_L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">target_R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> 
        <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="o">+</span><span class="p">[.</span><span class="mi">9</span><span class="p">],</span> 
        <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># or lw=2
</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xticks</span><span class="p">([])</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_yticks</span><span class="p">([])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="sh">'</span><span class="s">top</span><span class="sh">'</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="sh">'</span><span class="s">right</span><span class="sh">'</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="sh">'</span><span class="s">bottom</span><span class="sh">'</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="sh">'</span><span class="s">left</span><span class="sh">'</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">for</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">label</span><span class="p">]</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">([</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span><span class="n">shift</span><span class="p">],</span> <span class="p">[</span><span class="sh">'</span><span class="s">Source</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">Target</span><span class="sh">'</span><span class="p">]):</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,</span>  <span class="n">va</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span></code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/gaussian_to_spiral_crossing_lines-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/gaussian_to_spiral_crossing_lines-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/gaussian_to_spiral_crossing_lines-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/gaussian_to_spiral_crossing_lines.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="callout-block"> <b>Straight Trajectories == Linear Interpolation</b><br> The idea of trying straight trajectories at constant speed is *identical* to simple linear interpolation between source and target data points.<d-footnote> This is not the <i>only</i> choice for trial trajectories. We could instead use a variance-preserving "cosine interpolation" scheme. This results in noticeably straighter learned flow trajectories than those obtained from linear interpolation, but the linear case is simpler to explain here. See [the executable version of this post](https://colab.research.google.com/drive/1LfFgfvykgZOi9fcduE_Zkt1QYJxPKNtx?usp=sharing) for the option to use cosine interpolation.</d-footnote> </div> <p>There are big issues with doing this: The random pairing results in lots of trajectories that cross each other. But this is a <em>starting point</em> for Flow Matching.<d-footnote>"We'll cross the streams." -- Ghostbusters (1984)</d-footnote></p> <p>…well, ok not quite: we’re going to allow the <em>trajectories of individual points</em> to cross as we train the model. This <em>is</em> a bit “confusing” for the model, which will be trying to learn a velocity field, and that isn’t defined where trajectories cross. Eventually, however, the model will learn to estimate the <em>aggregated motion</em> of many particles, which will sort of average out to arrive at the “bulk motion” of the flow. This is similar to how the Brownian motion <d-cite key="brownian_motion"></d-cite> of many air or water particles averages out on the macroscopic level, giving us streamlines that don’t cross.<d-footnote>A related example from science fiction: in the fictitous "psychohistory" theory of Isaac Asimov's *Foundation* series, the choices and "trajectories" of individual people can't be predicted, but the aggregated development of an entire society follows predictable paths. </d-footnote></p> <p>This is why flow matching is about transforming <em>distributions</em>, not individual points. The learned velocity field might not exactly match any of our training trajectories, but it captures the statistical flow needed to transform one distribution into another.</p> <p>Here’s a visualization from the code we’ll execute later in the lesson. We’ll plot…</p> <ol> <li>Our naive training trajectories (with crossings)</li> <li>The actual learned flow field (i.e., the velocity vector field)</li> <li>The paths (aka “trajectories”) that data points follow when flowing with the learned field</li> </ol> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Left: Training data uses simple straight lines (with many crossings). Middle: The learned flow (velocity vector) field is smooth and continuous. Right: Actual trajectories following the flow field don’t cross.</p> <h2 id="how-are-flows-learned">How Are Flows “Learned”?</h2> <p>The goal of the machine learning system is as follows: for any point in space and any time t between 0 and 1, we want to learn the correct <em>velocity</em> (direction and speed) that point should move. It’s like learning the “wind map” that will blow the starting distribution cloud into the shape of the target distribution cloud.</p> <p>Since neural networks are such useful engines for approximation and interpolation, we’ll let a neural network “learn” to estimate the mapping between locations and times (as inputs), and velocities (as outputs).</p> <div class="callout-block"> <b>Terminology: "Simulation Free"</b><br> You'll sometimes see flow-maching models being referred to as "simulation free." This is just an indication that the flow we arrive at is not the result of any explicit simulation of any process (physical or otherwise). The flow obtained arises simply from the aggregation (or "averaging out") of many particles moving along imagined straight lines and crossing paths. </div> <h3 id="the-neural-networks-job">The Neural Network’s Job</h3> <p>The neural network has one job: given a position in space and a time, to output a velocity vector. <em>That’s all it does.</em> Below is the code for this model that will “learn” to estimate velocity vectors.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">import</span> <span class="n">torch.nn.functional</span> <span class="k">as</span> <span class="n">F</span>

<span class="k">class</span> <span class="nc">VelocityNet</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">h_dim</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fc_in</span>  <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">input_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fc2</span>    <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h_dim</span><span class="p">,</span> <span class="n">h_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fc3</span>    <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h_dim</span><span class="p">,</span> <span class="n">h_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fc_out</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h_dim</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">act</span><span class="o">=</span><span class="n">F</span><span class="p">.</span><span class="n">gelu</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">expand</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Ensure t has the correct dimensions
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nf">act</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">fc_in</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nf">act</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nf">act</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">fc_out</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Instantiate the model
</span><span class="n">input_dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">model</span> <span class="o">=</span> <span class="nc">VelocityNet</span><span class="p">(</span><span class="n">input_dim</span><span class="p">)</span></code></pre></figure> <p>…That’s it! Looks pretty simple, right? That’s because to make the system work we’ll need more than just the velocity field model.</p> <p>Apart from the velocity model (i.e., the neural network, for us), the rest of the software system then uses these generated velocities to move points around. The model’s velocities are then used in a differential equation describing the small change to each particle’s position $\vec{r}$ over a short time $dt$:</p> \[d\vec{r} = \vec{v}(\vec{r},t) dt\] <p>That equation is integrated by some (totally separate) numerical integration routine. A popular choice in the machine learning world is the “forward Euler” method, which is simple to implement, but will need to be upgraded (see further below) to get good results.</p> <details> <summary class="mycodeblock">Show code: Integrator to generate/predict samples using the trained model</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">fwd_euler_step</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">current_points</span><span class="p">,</span> <span class="n">current_t</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current_points</span><span class="p">,</span> <span class="n">current_t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current_points</span> <span class="o">+</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span> 

<span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">initial_points</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">fwd_euler_step</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                   <span class="n">save_trajectories</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">this </span><span class="sh">'</span><span class="s">sampling</span><span class="sh">'</span><span class="s"> routine is primarily used for visualization.</span><span class="sh">"""</span>
    <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    <span class="n">current_points</span> <span class="o">=</span> <span class="n">initial_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
    <span class="n">ts</span> <span class="o">=</span>  <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n_steps</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">warp_fn</span><span class="p">:</span> <span class="n">ts</span> <span class="o">=</span> <span class="nf">warp_fn</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_trajectories</span><span class="p">:</span> <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_points</span><span class="p">]</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">current_points</span> <span class="o">=</span> <span class="nf">step_fn</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">current_points</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">save_trajectories</span><span class="p">:</span> <span class="n">trajectories</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_trajectories</span><span class="p">:</span> <span class="k">return</span> <span class="n">current_points</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">trajectories</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">current_points</span> 

<span class="n">generate_samples</span> <span class="o">=</span> <span class="n">integrate_path</span> <span class="c1"># just lil' alias for the probability / diffusion model crowd ;-) </span></code></pre></figure> </details> <h2 id="training-code">Training Code</h2> <p>The goal of the training code is twofold:</p> <ol> <li>to expose the model to as many locations and times as possible – at least for those times &amp; locations that “matter most”. This exposure is what I’ll refer to as “coverage”.</li> <li>to force the model to learn to generate (approximately) correct velocities at those times and locations.</li> </ol> <p>That’s it. The training code doesn’t actually do any integration or “solving,” but we’ll typically execute the integration on some validation data during training just to visualize “how we’re doing” as the training progresses.</p> <details> <summary class="mycodeblock">Show code: viz routine calls integrator, makes pictures</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#| code-fold: true
#| code-summary: "Viz code: calls integrator to calc motion given v field, makes pictures"
</span>
<span class="k">def</span> <span class="nf">viz</span><span class="p">(</span><span class="n">val_points</span><span class="p">,</span> <span class="n">target_samples</span><span class="p">,</span> <span class="n">trained_model</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="bp">None</span><span class="p">,):</span>
    <span class="c1"># Generate and visualize new samples
</span>    <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">trained_model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    <span class="n">generated_samples</span><span class="p">,</span> <span class="n">trajectories</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">trained_model</span><span class="p">,</span> <span class="n">val_points</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_fn</span><span class="p">,</span> <span class="n">save_trajectories</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">n_viz</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># Number of trajectories to visualize
</span>    
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">val_points</span><span class="p">.</span><span class="nf">cpu</span><span class="p">(),</span> <span class="n">generated_samples</span><span class="p">.</span><span class="nf">cpu</span><span class="p">(),</span> <span class="n">target_samples</span><span class="p">.</span><span class="nf">cpu</span><span class="p">()]</span> 
    <span class="n">label_list</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Initial Points</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Generated Samples</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Target Data</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">Trajectories</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">color_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_color</span><span class="p">,</span> <span class="n">pred_color</span><span class="p">,</span> <span class="n">target_color</span><span class="p">]</span>
    <span class="n">global_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span> <span class="n">torch</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">data_list</span><span class="p">)),</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="n">torch</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">data_list</span><span class="p">)),</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">label_list</span><span class="p">)):</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="n">label_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="n">global_max</span><span class="p">,</span> <span class="n">global_max</span><span class="p">])</span> 
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="n">global_max</span><span class="p">,</span> <span class="n">global_max</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># non-trajectory plots
</span>            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> 
                          <span class="n">label</span><span class="o">=</span><span class="n">label_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Plot trajectory paths first
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_viz</span><span class="p">):</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Then plot start and end points for the SAME trajectories
</span>            <span class="n">start_points</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">n_viz</span><span class="p">]</span>
            <span class="n">end_points</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">n_viz</span><span class="p">]</span>  
            <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">start_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">start_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">source_color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Source Points</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">end_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">end_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">pred_color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Current Endpoints</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nf">legend</span><span class="p">()</span>

    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="c1"># Visualize the data
</span><span class="n">n_samples</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">source_samples</span> <span class="o">=</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
<span class="n">target_samples</span> <span class="o">=</span> <span class="nf">create_target_data</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
<span class="n">val_points</span> <span class="o">=</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Testing visualization routines (before training):</span><span class="sh">"</span><span class="p">)</span> 
<span class="nf">viz</span><span class="p">(</span><span class="n">val_points</span><span class="p">,</span> <span class="n">target_samples</span><span class="p">,</span>  <span class="n">model</span><span class="p">)</span> </code></pre></figure> </details> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Testing visualization routines (before training):    
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/viz_test-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/viz_test-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/viz_test-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/viz_test.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>The clever part about flow matching is how we train this network. For each training step:</p> <ol> <li>Sample random points from our source and target distributions, and pair the points</li> <li>Sample random times between 0 and 1</li> <li>Calculate the locations where these points <em>would</em> be at those times if they were moving at constant velocity from source to target locations</li> <li>Calculate what velocity they <em>would</em> have at those locations if they were moving at constant velocity</li> <li>Train the network to <em>predict</em> these velocities – which will end up “seeking the mean” when the network has to do the same for many, many points.</li> </ol> <p>Some readers may be skeptical: “Could such a scheme even work?” Theoretical assurances to that effect are where the pages probability-math come in. However, machine learning is also an experimental science, as in “Try it and find out!”</p> <p>Here we run the training code…</p> <details> <summary class="mycodeblock">Show code: train_model() training loop</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#| code-fold: true
#| code-summary: "Code for train_model() training loop"
</span><span class="kn">import</span> <span class="n">torch.optim</span> <span class="k">as</span> <span class="n">optim</span>

<span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">n_epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.003</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">status_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">viz_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">loss_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MSELoss</span><span class="p">()</span>
    <span class="n">step</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span>
    <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
        <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">),</span> <span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    
            <span class="c1"># by randomly generating new data each step, we prevent the model from merely memorizing
</span>            <span class="n">source_samples</span> <span class="o">=</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">target_samples</span> <span class="o">=</span> <span class="nf">create_target_data</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            
            <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">source_samples</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>  <span class="c1"># random times for traning
</span>            <span class="k">if</span> <span class="n">warp_fn</span><span class="p">:</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">warp_fn</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>    <span class="c1"># time warp is good for coverage but not as helpful for training as it is during integration/sampling
</span>            <span class="n">interpolated_samples</span> <span class="o">=</span> <span class="n">source_samples</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">target_samples</span> <span class="o">*</span> <span class="n">t</span>
            <span class="n">line_directions</span> <span class="o">=</span> <span class="n">target_samples</span> <span class="o">-</span> <span class="n">source_samples</span>
            
            <span class="n">drift</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">interpolated_samples</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">loss_fn</span><span class="p">(</span><span class="n">drift</span><span class="p">,</span> <span class="n">line_directions</span><span class="p">)</span>
            
            <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

            <span class="n">status_str</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Epoch [</span><span class="si">{</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">n_epochs</span><span class="si">}</span><span class="s">], Loss: </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span>
            <span class="n">pbar</span><span class="p">.</span><span class="nf">set_description</span><span class="p">(</span><span class="n">status_str</span><span class="p">)</span>
        
        <span class="nf">if </span><span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">viz_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
            <span class="nf">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Clear previous plots
</span>            <span class="nf">viz</span><span class="p">(</span><span class="n">val_points</span><span class="p">,</span> <span class="n">target_samples</span><span class="p">[:</span><span class="n">val_points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">model</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>  <span class="c1"># Close the figure to free memory
</span>            <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="n">epoch</span><span class="o">==</span><span class="n">n_epochs</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="n">status_str</span><span class="p">)</span>  <span class="c1"># keep last status from being cleared
</span>    
    <span class="k">return</span> <span class="n">model</span></code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/last_epoch_viz-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/last_epoch_viz-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/last_epoch_viz-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/last_epoch_viz.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Epoch [100/100], Loss: 1.8315
</code></pre></div></div> <p>Here’s an animation of integrating points along our model’s flow from start to finish:</p> <details> <summary class="mycodeblock">Show code: animating points in flow</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#| code-fold: true
#| code-summary: "Code for animating points in flow"
</span><span class="kn">import</span> <span class="n">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
<span class="kn">from</span> <span class="n">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">clear_output</span>
<span class="kn">from</span> <span class="n">matplotlib</span> <span class="kn">import</span> <span class="n">rc</span>
<span class="kn">import</span> <span class="n">os</span>

<span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_flow_animation</span><span class="p">(</span><span class="n">start_dist</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">titles</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n_frames</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                         <span class="n">step_fn</span><span class="o">=</span><span class="n">fwd_euler_step</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">save_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Create an animation showing multiple distribution flows
    
    Args:
        start_dist: Starting distribution
        models: List of models to animate
        titles: List of titles for each subplot (optional)
        figsize: Figure size (optional)
        n_frames: Number of animation frames
        integrator: Integration function to use
        jitter: Amount of jitter to add
        save_file: Path to save animation (optional)
        height: Height of each subplot
    </span><span class="sh">"""</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">(</span><span class="sh">'</span><span class="s">all</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># Close all open figures
</span>    
    <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="p">]</span>
    <span class="n">n_plots</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">titles</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="sh">'</span><span class="s">Flow </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="sh">'</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_plots</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">titles</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_plots</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Number of titles (</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">titles</span><span class="p">)</span><span class="si">}</span><span class="s">) must match number of models (</span><span class="si">{</span><span class="n">n_plots</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="c1"># Calculate figure size
</span>    <span class="k">if</span> <span class="n">figsize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">[</span><span class="n">height</span> <span class="o">*</span> <span class="n">n_plots</span><span class="p">,</span> <span class="n">height</span><span class="p">]</span>
    
    <span class="c1"># Create subplots
</span>    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_plots</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_plots</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>  <span class="c1"># Close the figure immediately
</span>
    
    <span class="c1"># Initialize scatters and trajectories
</span>    <span class="n">scatters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_trajectories</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Generate trajectories for each model
</span>    <span class="n">max_range</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">start_dist</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
        <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
        <span class="n">end_dist</span><span class="p">,</span> <span class="n">trajectories</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">start_dist</span><span class="p">.</span><span class="nf">clone</span><span class="p">().</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span>  
                                          <span class="n">step_fn</span><span class="o">=</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_fn</span><span class="p">,</span> <span class="n">save_trajectories</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">all_trajectories</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trajectories</span><span class="p">.</span><span class="nf">cpu</span><span class="p">())</span>
        <span class="n">scatters</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">wong_pink</span><span class="p">))</span>
        
        <span class="c1"># Update max range
</span>        <span class="n">max_range</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_range</span><span class="p">,</span> <span class="nf">abs</span><span class="p">(</span><span class="n">end_dist</span><span class="p">.</span><span class="nf">cpu</span><span class="p">()).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">())</span>
    
    <span class="c1"># Set up axes
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xticks</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">'</span><span class="s">top</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">right</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bottom</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">left</span><span class="sh">'</span><span class="p">]:</span>
            <span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="sh">"""</span><span class="s">Initialize animation</span><span class="sh">"""</span>
        <span class="k">for</span> <span class="n">scatter</span> <span class="ow">in</span> <span class="n">scatters</span><span class="p">:</span>
            <span class="n">scatter</span><span class="p">.</span><span class="nf">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[[],</span> <span class="p">[]])</span>
        <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">scatters</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Update animation frame</span><span class="sh">"""</span>
        <span class="c1"># Update axis limits (in case they need to be adjusted)
</span>        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        
        <span class="c1"># Update scatter positions
</span>        <span class="k">for</span> <span class="n">scatter</span><span class="p">,</span> <span class="n">trajectories</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">scatters</span><span class="p">,</span> <span class="n">all_trajectories</span><span class="p">):</span>
            <span class="n">scatter</span><span class="p">.</span><span class="nf">set_offsets</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="n">frame</span><span class="p">].</span><span class="nf">numpy</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">scatters</span><span class="p">)</span>
    
    <span class="c1"># Create animation
</span>    <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="p">.</span><span class="nc">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                 <span class="n">frames</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Handle saving or displaying
</span>    <span class="k">if</span> <span class="n">save_file</span><span class="p">:</span>
        <span class="n">os</span><span class="p">.</span><span class="nf">makedirs</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">save_file</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">anim</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="sh">'</span><span class="s">ffmpeg</span><span class="sh">'</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">HTML</span><span class="p">(</span><span class="sa">f</span><span class="sh">"""</span><span class="s">&lt;center&gt;&lt;video height=</span><span class="sh">"</span><span class="s">350</span><span class="sh">"</span><span class="s"> controls loop&gt;&lt;source src=</span><span class="sh">"</span><span class="si">{</span><span class="n">anim_file</span><span class="si">}</span><span class="sh">"</span><span class="s"> type=</span><span class="sh">"</span><span class="s">video/mp4</span><span class="sh">"</span><span class="s">&gt;
              Your browser does not support the video tag. &lt;/video&gt;&lt;/center&gt;</span><span class="sh">"""</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># direct matplotlib anim offers better controls but makes ipynb file size huge
</span>        <span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">animation</span><span class="sh">'</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="sh">'</span><span class="s">jshtml</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">HTML</span><span class="p">(</span><span class="n">anim</span><span class="p">.</span><span class="nf">to_jshtml</span><span class="p">())</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>



<span class="n">anim_file</span> <span class="o">=</span> <span class="sh">'</span><span class="s">images/particles_fm.mp4</span><span class="sh">'</span>
<span class="nf">create_flow_animation</span><span class="p">(</span><span class="n">val_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">(),</span> <span class="n">models</span><span class="o">=</span><span class="p">[</span><span class="n">fm_model</span><span class="p">],</span> <span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">Flow Matching</span><span class="sh">'</span><span class="p">],</span>
                      <span class="n">n_frames</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">save_file</span><span class="o">=</span><span class="n">anim_file</span><span class="p">)</span></code></pre></figure> </details> <center> <video width="50%" controls="" loop=""> <source src="/2025/assets/img/2025-04-28-flow-with-what-you-know/particles_fm.mp4" type="video/mp4"></source> Your browser does not support the video tag. </video> </center> <p>So, even though we trained using trajectories that crossed, the model learned smooth and non-crossing (but curvy!) trajectories. Here’s a static plot of these:</p> <details> <summary class="mycodeblock">Show code: make the static plot</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">plot_training_trajectories_vs_learned_flow</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
   <span class="sh">"""</span><span class="s">Compare training trajectories with learned flow field</span><span class="sh">"""</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
   
   <span class="c1"># 1. Plot some training trajectories
</span>   <span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">)</span>
   <span class="n">n_trajs</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># Number of trajectories to show
</span>   <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
   <span class="n">source</span> <span class="o">=</span> <span class="nf">create_gaussian_data</span><span class="p">(</span><span class="n">n_trajs</span><span class="p">)</span>
   <span class="n">target</span> <span class="o">=</span> <span class="nf">create_square_data</span><span class="p">(</span><span class="n">n_trajs</span><span class="p">)</span>
   <span class="n">current_points</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="nf">clone</span><span class="p">().</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

   
   <span class="c1"># Plot straight-line trajectories from source to target
</span>   <span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_trajs</span><span class="p">):</span>
       <span class="n">traj</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">times</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">times</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
       <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="sh">'</span><span class="s">b-</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Training Trajectories</span><span class="se">\n</span><span class="s">(with crossings)</span><span class="sh">'</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">axis</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
   
   <span class="c1"># 2. Plot learned flow field
</span>   <span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">)</span>
   <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
   <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="sh">'</span><span class="s">ij</span><span class="sh">'</span><span class="p">)</span>
   <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">X</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="nf">flatten</span><span class="p">()],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
   
   <span class="c1"># with torch.no_grad():
</span>   <span class="c1">#     t =  0.5  # Show flow field at t=0.5
</span>   <span class="c1">#     ones = torch.ones(points.size(0), 1)
</span>
   <span class="n">ones</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
   <span class="n">t</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
   <span class="n">velocities</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">t</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
   <span class="c1">#print("points.shape, ones.shape = ",points.shape, ones.shape) 
</span>   <span class="c1">#velocities = model(points, t*ones)
</span>   <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="nf">cpu</span><span class="p">()</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">quiver</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> 
             <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
             <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Learned Flow Field</span><span class="se">\n</span><span class="s">at t=0.5</span><span class="sh">'</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">axis</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
   
   <span class="c1"># 3. Plot actual paths taken using learned flow
</span>   <span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">)</span>
   <span class="n">source</span> <span class="o">=</span> <span class="nf">create_gaussian_data</span><span class="p">(</span><span class="n">n_trajs</span><span class="p">)</span>
   
   <span class="c1"># Use RK4 to follow the learned flow
</span>   <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="n">n_steps</span> <span class="o">=</span> <span class="mi">20</span>
   <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_steps</span>
   
   <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
       <span class="n">ones</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">current_points</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
           <span class="n">paths</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">())</span>
           
           <span class="c1"># RK4 step
</span>           <span class="n">t</span> <span class="o">=</span> <span class="n">ones</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
           <span class="n">k1</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current_points</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
           <span class="n">k2</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current_points</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
           <span class="n">k3</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current_points</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
           <span class="n">k4</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current_points</span> <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
           
           <span class="n">current_points</span> <span class="o">=</span> <span class="n">current_points</span> <span class="o">+</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="o">/</span><span class="mi">6</span>
   
   <span class="n">paths</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">paths</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
   
   <span class="c1"># Plot the actual paths
</span>   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_trajs</span><span class="p">):</span>
       <span class="n">traj</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
       <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Actual Paths</span><span class="se">\n</span><span class="s">Following Learned Flow</span><span class="sh">'</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">axis</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
   
   <span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">savefig</span><span class="p">(</span><span class="sh">'</span><span class="s">images/cross_uncross_plot.png</span><span class="sh">'</span><span class="p">)</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
   <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="c1"># Run the visualization
</span><span class="nf">plot_training_trajectories_vs_learned_flow</span><span class="p">(</span><span class="n">fm_model</span><span class="p">)</span></code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/cross_uncross_plot.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Even though the trajectories on the right are smooth and non-crossing, their curviness means that we need to integrate slowly and carefully to avoid accruing significant error. Good news: the “Rectified Flow” paper of Liu et al <d-cite key="rectified_flow"></d-cite> offers a powerful way to speed up the integration by “straightening” the curved trajectories, a method they call “Reflow.”</p> <h1 id="reflow-to-go-straighter--faster">“Reflow” to Go Straighter &amp; Faster</h1> <p>The Reflow idea is that, instead of randomly pairing source and target points when choosing straight trajectories, we use “simulated target points” by integrating the source points forward using the learned flow model. Then we use those endpoints as the targets and assume linear motion as before.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflow_diagram-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflow_diagram-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflow_diagram-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflow_diagram.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>This has the effect of straightening out the curved trajectory of the flow matching model, making the new “reflowed” trajectories much easier and faster to integrate!</p> <p>Essentially, Reflow is a “teacher-student” paradigm in which the (pre-)trained flow-matching model is the teacher, and the new Reflowed model is the student. One can also think of this as a kind of distillation, akin to “consistency models” <d-cite key="consistency_models"></d-cite>.</p> <p>Before we can rely on those integrated endpoints, we should make a couple of improvements to how we use the model we just trained.</p> <h2 id="upgrading-our-gear-first">Upgrading Our Gear First</h2> <p>Neither of these upgrades require retraining the velocity model. They just help to make more efficient, accurate use of it while integrating (i.e., while moving data points along the flow) so we’ll have an effective “teacher” for the “student” Reflow model we’ll train below.</p> <h3 id="more-points-where-needed-via-time-warping">More Points Where Needed (via Time Warping)</h3> <p>You may notice that many of the trajectories are sharply curved in the middle but are straight near the start and end. Just as you’d slow down when driving around a sharp turn, we should take smaller integration steps in these curved regions for the sake of accuracy.</p> <p>The idea of non-uniform temporal sampling appears throughout generative models. Esser et al.’s “FLUX” paper<d-cite key="flux_paper"></d-cite> specifically designs their sampling distribution to concentrate points in the middle of the integration where accuracy is most crucial. The same principle applies here:</p> <ul> <li>during <strong>training,</strong> we want good “coverage” to expose the model to significant places and times where it needs to learn to approximate the correct velocities, and</li> <li>during <strong>inference (i.e., integration),</strong> high-curvature segments will require shorter time steps to maintain accuracy (i.e., to keep from missing the intended destination).</li> </ul> <p>One handy S-shaped time-warping function is this polynomial that lets us vary the concentration of points<d-footnote>The $f(t)$ shown here is a close approximation to the "mode function" Eq. 20 in <d-cite key="flux_paper"></d-cite>, with their $s$ being about (1.75 - $s_{\rm mine}$), and with $t\rightarrow 1-t$. The $f(t)$ blue line is right underneath their purple line in the Desmos graph below -- we didn't plan that, just similar minds at work! Both our curves can do the Karras et al cosine schedule, shown in green in the the Desmos figure.</d-footnote>:</p> \[f(t) = 4(1-s)t^3 + 6(s-1) t^2 + (3-2s)t, \ \ \ \ \ \ t\in[0,1], \ \ \ s\in[0,3/2]\] <center> <a href="https://www.desmos.com/calculator/g6ffbljlng" rel="external nofollow noopener noopener noreferrer" target="_blank"> <iframe src="https://www.desmos.com/calculator/hfjxlwycmz?embed" width="225" height="225" style="border: 1px solid #ccc" frameborder="0"></iframe> <br>Interactive Desmos Graph Link</a><br><br> </center> <p>The parameter $s$ is the slope at t=1/2, and controls where points concentrate: values between 0 and 1 give us more points in the middle, which is exactly what we want for these curved trajectories. The value $s=0.5$ is a good choice, as we’ll see shortly.</p> <p>This approach can improve accuracy and/or require fewer total integration steps. Let’s look at the results of different amounts of time-warping around a simple parabola:</p> <details> <summary class="mycodeblock">Show code: warp_time() and parabola example</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">warp_time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="p">.</span><span class="mi">5</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Parametric Time Warping: s = slope in the middle. 
        s=1 is linear time, s &lt; 1 goes slower near the middle, s&gt;1 goes slower near the ends
        s = 1.5 gets very close to the </span><span class="sh">"</span><span class="s">cosine schedule</span><span class="sh">"</span><span class="s">, i.e. (1-cos(pi*t))/2, i.e. sin^2(pi/2*x)</span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">s</span><span class="o">&gt;</span><span class="mf">1.5</span><span class="p">:</span> <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">s=</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s"> is out of bounds.</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">tw</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> 
    <span class="k">if</span> <span class="n">dt</span><span class="p">:</span>                           <span class="c1"># warped time-step requested; use derivative
</span>        <span class="k">return</span> <span class="n">tw</span><span class="p">,</span>  <span class="n">dt</span> <span class="o">*</span> <span class="mi">12</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">tw</span>


<span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">partial</span> 

<span class="n">parab</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># curve shape
</span><span class="n">d_parab</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>     <span class="c1"># derivative
</span><span class="n">ds</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">d_parab</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># differential arc length
</span>
<span class="k">def</span> <span class="nf">calculate_total_arc_length</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Calculate the total arc length of the parabola y = 4(x - 0.5)**2 from x=0 to x=1</span><span class="sh">"""</span>
    <span class="n">x_values</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">arc_length_values</span> <span class="o">=</span> <span class="nf">ds</span><span class="p">(</span><span class="n">x_values</span><span class="p">)</span>
    <span class="n">total_arc_length</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">trapz</span><span class="p">(</span><span class="n">arc_length_values</span><span class="p">,</span> <span class="n">x_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total_arc_length</span>

<span class="k">def</span> <span class="nf">fake_velocity_model</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">For demo purposes only: Follow a parabolic path and move at unit speed
    Compute the x and y components of the velocity along the parabola y = 4(x - 0.5)^2</span><span class="sh">"""</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>    
    <span class="n">slope</span> <span class="o">=</span> <span class="nf">d_parab</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">torch</span><span class="p">.</span><span class="nf">ones_like</span><span class="p">(</span><span class="n">slope</span><span class="p">),</span> <span class="n">slope</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">unit_velocity</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">/</span> <span class="n">magnitude</span>    
    <span class="k">return</span> <span class="n">unit_velocity</span><span class="o">*</span><span class="n">speed</span>

<span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">integrate_motion_along_parabola</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">initial_points</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">fwd_euler_step</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,):</span>
    <span class="sh">"""</span><span class="s">one-off integrator used only for this one visualization figure. don</span><span class="sh">'</span><span class="s">t use for anything else</span><span class="sh">"""</span>
    <span class="n">current_points</span> <span class="o">=</span> <span class="n">initial_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
    <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_points</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">clone</span><span class="p">()]</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">)</span> 
    <span class="n">ts</span> <span class="o">=</span> <span class="nf">warp_time</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># here's the time worpage
</span>    <span class="n">speed</span> <span class="o">=</span> <span class="nf">calculate_total_arc_length</span><span class="p">()</span>   <span class="c1"># Total travel time is 1.0 so speed "=" distance
</span>    <span class="n">scaled_model</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="n">speed</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">current_points</span> <span class="o">=</span> <span class="nf">step_fn</span><span class="p">(</span> <span class="n">scaled_model</span> <span class="p">,</span> <span class="n">current_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">(),</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>  <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">trajectories</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_points</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">clone</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>

<span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">viz_parabola_with_steps</span><span class="p">(</span><span class="n">step_fn</span><span class="o">=</span><span class="n">fwd_euler_step</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">28</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">varies warp parameter s and integrates along a parabola</span><span class="sh">"""</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="n">t_curve</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

    <span class="n">n_t_points</span> <span class="o">=</span> <span class="n">n_steps</span> <span class="c1"># 28 if step_fn==fwd_euler_step else 6
</span>    <span class="n">t_points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n_t_points</span><span class="p">)</span>

    <span class="n">n_s</span> <span class="o">=</span> <span class="mi">6</span>    <span class="c1"># number of different s values to show
</span>    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_s</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">n_s</span><span class="o">*</span><span class="mf">2.8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Integration scheme = </span><span class="si">{</span><span class="n">step_fn</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.05</span><span class="p">)</span>
    <span class="n">initial_points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>                   <span class="c1"># one point in the top left
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(.</span><span class="mi">25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)):</span>   <span class="c1"># warp time by different amounts via s parameter
</span>        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">plot</span><span class="p">(</span><span class="n">t_curve</span><span class="p">,</span> <span class="nf">parab</span><span class="p">(</span><span class="n">t_curve</span><span class="p">))</span>    <span class="c1"># solid line showing path
</span>        <span class="n">traj</span> <span class="o">=</span> <span class="nf">integrate_motion_along_parabola</span><span class="p">(</span><span class="n">fake_velocity_model</span><span class="p">,</span> <span class="n">initial_points</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_t_points</span><span class="p">,</span> 
                    <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">step_fn</span><span class="p">).</span><span class="nf">squeeze</span><span class="p">()</span> 
        <span class="n">err_str</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">error=</span><span class="si">{</span><span class="n">F</span><span class="p">.</span><span class="n">mse_loss</span><span class="p">(</span><span class="n">parab</span><span class="p">(</span><span class="n">traj</span><span class="p">[</span><span class="si">:</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">traj</span><span class="p">[</span><span class="si">:</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">g</span><span class="si">}</span><span class="sh">"</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="sh">'</span><span class="s">s = </span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}{</span><span class="n">err_str</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="n">wong_cmap</span><span class="o">*</span><span class="mi">2</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">legend</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="sh">'</span><span class="s">upper center</span><span class="sh">'</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">markerscale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">handlelength</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">legend</span><span class="p">.</span><span class="nf">get_texts</span><span class="p">():</span>
            <span class="n">text</span><span class="p">.</span><span class="nf">set_ha</span><span class="p">(</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">)</span>

        <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Even Spacing</span><span class="sh">'</span><span class="p">)</span> 
            
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">More Points in Middle</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">More Points at Ends</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="nf">viz_parabola_with_steps</span><span class="p">()</span> </code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_fwd_euler-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_fwd_euler-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_fwd_euler-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_fwd_euler.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>While the results for $s=0.5$ are better than the others, we see that <em>none</em> of these examples make it all the way around the parabola (to the point (1,1))! If we’re going to be using the endpoints integrated from the flow matching model as proxies for the true target data, we should have some confidence that those endpoints are actually “reaching” the target data. We could add more (smaller) steps to the integration, but there’s another way: upgrade the integration (i.e. sampling) operation to a higher order of accuracy.</p> <div class="callout-block"> <b>Note:</b> Although retraining the flow-matching model with time warping isn't "required," it can improve results by better sampling the domain where accurate velocity approximations matter most. The <a href="https://tinyurl.com/iclr-2025-flow-blogpost-colab" rel="external nofollow noopener noopener noreferrer" target="_blank">executable version of this post</a> offers the option to retrain at this point, but for our toy problem the improvement is minimal. </div> <h3 id="better-integration--sampling">Better Integration / Sampling</h3> <p>Although forward Euler is surprisingly popular in ML circles, those with simulation backgrounds eye it with suspicion: despite being fast (<em>per step</em>) and easy to implement, it’s also highly inaccurate and can lead to instabilities. The poor accuracy may not be an issue when everything’s an approximation anyway, but we can do a lot better.</p> <p>People who work with diffusion models know this. For example, Katherine Crowson’s k-diffusion package<d-footnote><a href="https://github.com/crowsonkb/k-diffusion" rel="external nofollow noopener noopener noreferrer" target="_blank">https://github.com/crowsonkb/k-diffusion</a></d-footnote> offers a bevy of integration choices. For now, we’ll just implement the popular 4th-order Runge-Kutta (RK4) scheme. Per step, it’s more “expensive” than forward Euler in that each RK4 step requires 4 function evaluations instead of forward Euler’s single evaluation, and RK4 requires some extra storage, but the advantages you gain in accuracy are seriously worth it. Since our learned flow trajectories are <em>smooth</em>, a few large steps with a higher-order integrator like RK4 can totally smoke the earlier forward Euler results.</p> <details> <summary class="mycodeblock">Show code: RK4 step</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">rk4_step</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="c1"># function that takes (y,t) and returns dy/dt, i.e. velocity
</span>             <span class="n">y</span><span class="p">,</span> <span class="c1"># current location
</span>             <span class="n">t</span><span class="p">,</span> <span class="c1"># current t value
</span>             <span class="n">dt</span><span class="p">,</span> <span class="c1"># requested time step size 
</span>             <span class="p">):</span>
    <span class="n">k1</span> <span class="o">=</span>  <span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span>  <span class="nf">f</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 
    <span class="n">k3</span> <span class="o">=</span>  <span class="nf">f</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k2</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 
    <span class="n">k4</span> <span class="o">=</span>  <span class="nf">f</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k3</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>

<span class="nf">viz_parabola_with_steps</span><span class="p">(</span><span class="n">step_fn</span><span class="o">=</span><span class="n">rk4_step</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span> </code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_rk4-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_rk4-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_rk4-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/integrate_parabola_rk4.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>It’s cool how the RK4 results, despite showing much less error than the Euler results, actually involve less computational cost in terms of total number of function evaluations, although the RK4 scheme needs 4 times the storage compared to forward Euler. (The good news is that no PyTorch gradients need to be stored; the integrator is only ever used when the model is in “eval” mode.)</p> <div class="callout-block"> <b>Note:</b> We're only going to use the RK4-powered integrator to run inference on the flow matching model to provide the "simulated target data" while we train the Reflow model. Once we have the Reflow model trained, the new trajectories we get from it will be so straight that even forward Euler should be "good enough"! </div> <h2 id="learning-to-reflow">Learning to “Reflow”</h2> <p>When we train the “Reflowed” model, aka the student model, note that the “target data” will no longer be supplied by the true target data anymore. Rather, we will be using the trajectory endpoints integrated/generated using the teacher model, i.e. the pretrained flow matching model.</p> <p>So we might ask, “How close of an approximation are those learned flow endpoints to the real thing?” We’re going to be approximating an approximation, but how good is the first approximation?</p> <p>Let’s take a brief look…</p> <details> <summary class="mycodeblock">Show code</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#| code-fold: true
#| code-summary: "quick check of how our flow endpoints are looking"
</span><span class="n">pretrained_model</span> <span class="o">=</span> <span class="n">fm_model</span> 
<span class="n">pretrained_model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
<span class="n">reflow_targets</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">pretrained_model</span><span class="p">,</span> <span class="n">val_points</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">rk4_step</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_time</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="p">]</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">zip</span><span class="p">([</span><span class="n">val_points</span><span class="p">,</span>   <span class="n">reflow_targets</span><span class="p">,</span> <span class="n">target_samples</span><span class="p">],</span> 
                                             <span class="p">[</span><span class="n">source_color</span><span class="p">,</span> <span class="n">pred_color</span><span class="p">,</span>     <span class="n">target_color</span><span class="p">],</span>
                                             <span class="p">[</span><span class="sh">'</span><span class="s">Source Data</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Learned Flow Endpoints</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">True Target Data</span><span class="sh">'</span><span class="p">])):</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span></code></pre></figure> </details> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/check_viz_b4_reflow-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/check_viz_b4_reflow-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/check_viz_b4_reflow-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/check_viz_b4_reflow.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>….ok, so we see the learned outputs are a bit different from the true data, but they’re not bad. Let’s now train the “reflow” model.</p> <h3 id="train-the-reflowed-model">Train the Reflowed Model</h3> <p>There’s one small but crucial change from the previous training code to this one, namely what we use as target data:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##  target_samples = create_target_data(batch_size)           # Previous "random pairing"
</span><span class="n">target_samples</span> <span class="o">=</span> <span class="nf">integrator</span><span class="p">(</span><span class="n">pretrained_model</span><span class="p">,</span> <span class="n">source_samples</span><span class="p">)</span> <span class="c1"># Reflow!
</span></code></pre></div></div> <details> <summary class="mycodeblock">Show code: new training loop w/ ReFlowed targets</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">train_reflow_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pretrained_model</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                          <span class="n">n_epochs</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> 
                          <span class="n">status_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">viz_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># in epochs
</span>                          <span class="n">new_points_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># in steps 
</span>                          <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_time</span><span class="p">,</span> 
                          <span class="n">step_fn</span><span class="o">=</span><span class="n">rk4_step</span><span class="p">,</span> <span class="c1"># rk4 so we get high-quality outputs while reflowing
</span>                          <span class="p">):</span>
    <span class="sh">"""</span><span class="s">This is almost IDENTICAL to the previous training routine. 
        The difference is the change in </span><span class="sh">"</span><span class="s">target_samples</span><span class="sh">"</span><span class="s"> via what the RF authors call </span><span class="sh">"</span><span class="s">ReFlow</span><span class="sh">"</span><span class="s">: 
        Instead of (randomly) paring source points with points in the </span><span class="sh">"</span><span class="s">true target distribution</span><span class="sh">"</span><span class="s">, 
        we use the pretrained/teacher model to integrate the source points to their (predicted) flow endpoints 
        and use THOSE as the </span><span class="sh">"</span><span class="s">target</span><span class="sh">"</span><span class="s"> values.
    </span><span class="sh">"""</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">loss_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MSELoss</span><span class="p">()</span>
    <span class="n">step</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span>
    <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
        <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">),</span> <span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="n">new_points_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># you could in theory not draw new points with each step, though we will. 
</span>                <span class="n">source_samples</span> <span class="o">=</span> <span class="nf">create_source_data</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pretrained_model</span><span class="p">:</span>   <span class="c1"># HERE is the ReFlow operation...
</span>                    <span class="n">target_samples</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">pretrained_model</span><span class="p">,</span> <span class="n">source_samples</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">rk4_step</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_time</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>  
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_samples</span> <span class="o">=</span> <span class="nf">create_target_data</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="c1"># this function also supports fm models from scratch
</span>                    
            <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">source_samples</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="c1"># random times for training
</span>            <span class="k">if</span> <span class="n">warp_fn</span><span class="p">:</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">warp_fn</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># time warp here (different from use in integrator!) helps focus "coverage" i.e. sampling the space
</span>                
            <span class="n">interpolated_samples</span> <span class="o">=</span> <span class="n">source_samples</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">target_samples</span> <span class="o">*</span> <span class="n">t</span>            
            <span class="n">v</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">interpolated_samples</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">line_directions</span> <span class="o">=</span> <span class="n">target_samples</span> <span class="o">-</span> <span class="n">source_samples</span> 
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">loss_fn</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">line_directions</span><span class="p">)</span>
            
            <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
            
            <span class="n">pbar</span><span class="p">.</span><span class="nf">set_description</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Epoch [</span><span class="si">{</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">n_epochs</span><span class="si">}</span><span class="s">], Loss: </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">g</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="nf">if </span><span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">viz_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
            <span class="nf">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Clear previous plots
</span>            <span class="nf">viz</span><span class="p">(</span><span class="n">val_points</span><span class="p">,</span> <span class="n">target_samples</span><span class="p">[:</span><span class="n">val_points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">model</span><span class="p">)</span>  <span class="c1"># don't need rk4 for reflow'd model viz b/c paths r straight
</span>            <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>  <span class="c1"># Close the figure to free memory
</span>            <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">model</span></code></pre></figure> </details> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>

<span class="c1"># Note that the student/reflow model could have a simpler architecture 
# than the teacher/pretrained model, but... we'll just keep 'em the same :shrug:
</span><span class="n">reflowed_model</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">pretrained_model</span><span class="p">)</span> <span class="c1"># no need to start from scratch, use teacher's weights
</span><span class="n">reflowed_model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>               <span class="c1"># make sure we have gradients turned on
</span>
<span class="n">reflowed_model</span> <span class="o">=</span> <span class="nf">train_reflow_model</span><span class="p">(</span><span class="n">reflowed_model</span><span class="p">,</span> <span class="n">pretrained_model</span><span class="o">=</span><span class="n">pretrained_model</span><span class="p">)</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflowed_inp_gen_targ_traj-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflowed_inp_gen_targ_traj-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflowed_inp_gen_targ_traj-1400.webp"></source> <img src="/2025/assets/img/2025-04-28-flow-with-what-you-know/reflowed_inp_gen_targ_traj.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Now look how straight the trajectories are! Let’s compare animations of the original flow matching model with the “Reflowed” model:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#| code-fold: true
#| code-summary: "Making movie for particle animation comparison"
</span><span class="n">rect_eval</span> <span class="o">=</span> <span class="n">reflowed_model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>

<span class="n">anim_file</span> <span class="o">=</span> <span class="sh">"</span><span class="s">images/particles_fm_vs_rf.mp4</span><span class="sh">"</span>
<span class="nf">create_flow_animation</span><span class="p">(</span><span class="n">val_points</span><span class="p">.</span><span class="nf">clone</span><span class="p">(),</span> <span class="n">models</span><span class="o">=</span><span class="p">[</span><span class="n">pretrained_model</span><span class="p">,</span> <span class="n">reflowed_model</span><span class="p">],</span> 
        <span class="n">n_frames</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">Flow Matching</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">Reflowed Flow</span><span class="sh">'</span><span class="p">],</span> <span class="n">save_file</span><span class="o">=</span><span class="n">anim_file</span><span class="p">)</span>
</code></pre></div></div> <video width="100%" controls="" loop=""> <source src="/2025/assets/img/2025-04-28-flow-with-what-you-know/particles_fm_vs_rf.mp4" type="video/mp4"></source> Your browser does not support the video tag. </video> <p>Notice how the flow matching trajectories on the left have the data moving inward a ways and then back out, whereas the reflowed trajectories move directly from start to finish with no backtracking.</p> <p>The next movie shows an animation of “streamlines” with arrows for the local vector field. Note how the shapes on the right change very little over time compared to those on the left. We’ll say a bit more about that below.</p> <details> <summary class="mycodeblock">Show code: streamline animation</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@torch.no_grad</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_streamline_animation</span><span class="p">(</span><span class="n">start_dist</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n_frames</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">show_points</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">titles</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                                <span class="n">step_fn</span><span class="o">=</span><span class="n">fwd_euler_step</span><span class="p">,</span>  <span class="c1"># euler's ok for reflowed model bc/paths are straight
</span>                                <span class="n">save_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                               <span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create an animation showing distribution flow with streamplot background</span><span class="sh">"""</span>
    <span class="n">device</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    <span class="n">figsize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">titles</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> 
        <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Flow Matching</span><span class="sh">'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">model2</span><span class="p">:</span> <span class="n">titles</span> <span class="o">+=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Reflowed Model</span><span class="sh">'</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">model2</span><span class="p">:</span> 
        <span class="n">figsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">n_plots</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">model2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_plots</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_plots</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

    <span class="n">end_dist</span><span class="p">,</span> <span class="n">trajectories</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">start_dist</span><span class="p">.</span><span class="nf">clone</span><span class="p">().</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_time</span><span class="p">,</span> <span class="n">save_trajectories</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">scatter</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">wong_pink</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model2</span><span class="p">:</span> 
        <span class="n">_</span><span class="p">,</span> <span class="n">trajectories2</span> <span class="o">=</span> <span class="nf">integrate_path</span><span class="p">(</span><span class="n">model2</span><span class="p">,</span> <span class="n">start_dist</span><span class="p">.</span><span class="nf">clone</span><span class="p">().</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">step_fn</span><span class="o">=</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">warp_fn</span><span class="o">=</span><span class="n">warp_time</span><span class="p">,</span> <span class="n">save_trajectories</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">scatter2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">scatter</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">wong_pink</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">max_range</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span> <span class="nf">abs</span><span class="p">(</span><span class="n">start_dist</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">(),</span> <span class="nf">abs</span><span class="p">(</span><span class="n">end_dist</span><span class="p">).</span><span class="nf">max</span><span class="p">().</span><span class="nf">item</span><span class="p">()</span> <span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">titles</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>


    <span class="c1"># Create grid for streamplot
</span>    <span class="n">grid_dim</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">,</span> <span class="n">grid_dim</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">,</span> <span class="n">grid_dim</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># Convert grid to torch tensor for model input
</span>    <span class="n">grid_points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">X</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="nf">flatten</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">wong_pink</span> <span class="k">if</span> <span class="n">show_points</span> <span class="nf">else </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> 

    <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_frames</span> 
    
    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">clear</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
        <span class="n">scatter</span><span class="p">.</span><span class="nf">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[[],</span> <span class="p">[]])</span>
        <span class="k">if</span> <span class="n">model2</span><span class="p">:</span>
                <span class="n">scatter</span><span class="p">.</span><span class="nf">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[[],</span> <span class="p">[]])</span>
                <span class="nf">return </span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span><span class="n">scatter2</span><span class="p">)</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">scatter</span><span class="p">,)</span>
    
    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">clear</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">titles</span><span class="p">:</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_yticks</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">'</span><span class="s">top</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">right</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">bottom</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">left</span><span class="sh">'</span><span class="p">]:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">].</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="c1"># Update scatter plot
</span>        <span class="n">current</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">current</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">current</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model2</span><span class="p">:</span>
            <span class="n">current2</span> <span class="o">=</span> <span class="n">trajectories2</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>
            <span class="n">scatter2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">current2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">current2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate vector field for current time
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">grid_points</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">frame</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nf">warp_time</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
        <span class="n">velocities</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">grid_points</span><span class="p">,</span> <span class="n">t</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">x_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="n">y_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">max_range</span><span class="p">,</span> <span class="n">max_range</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="n">X_arrows</span><span class="p">,</span> <span class="n">Y_arrows</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">)</span>
        <span class="n">start_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">column_stack</span><span class="p">((</span><span class="n">X_arrows</span><span class="p">.</span><span class="nf">ravel</span><span class="p">(),</span> <span class="n">Y_arrows</span><span class="p">.</span><span class="nf">ravel</span><span class="p">()))</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">streamplot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">V</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span>
             <span class="n">density</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># Controls line spacing
</span>             <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="c1"># (0, 0, 1, 0.7),
</span>             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span>
             <span class="n">start_points</span><span class="o">=</span><span class="n">start_points</span><span class="p">,</span>  <span class="c1"># This should give more arrows along paths
</span>             <span class="n">arrowsize</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
             <span class="n">arrowstyle</span><span class="o">=</span><span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span><span class="p">)</span>  
        
        <span class="k">if</span> <span class="n">model2</span><span class="p">:</span> 
            <span class="n">velocities2</span> <span class="o">=</span> <span class="nf">model2</span><span class="p">(</span><span class="n">grid_points</span><span class="p">,</span> <span class="n">t</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
            <span class="n">U2</span> <span class="o">=</span> <span class="n">velocities2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">velocities2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">start_points2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">column_stack</span><span class="p">((</span><span class="n">X_arrows</span><span class="p">.</span><span class="nf">ravel</span><span class="p">(),</span> <span class="n">Y_arrows</span><span class="p">.</span><span class="nf">ravel</span><span class="p">()))</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">streamplot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">U2</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">V2</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span>
                 <span class="n">density</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># Controls line spacing
</span>                 <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="c1"># (0, 0, 1, 0.7),
</span>                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">maxlength</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span>
                 <span class="n">start_points</span><span class="o">=</span><span class="n">start_points2</span><span class="p">,</span>  <span class="c1"># This should give more arrows along paths
</span>                 <span class="n">arrowsize</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                 <span class="n">arrowstyle</span><span class="o">=</span><span class="sh">'</span><span class="s">-&gt;</span><span class="sh">'</span><span class="p">)</span> 


        <span class="c1"># Update particle positions
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">frame</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">dtw</span> <span class="o">=</span> <span class="nf">warp_time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)).</span><span class="nf">cpu</span><span class="p">()</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">dtw</span>
        <span class="k">if</span> <span class="n">model2</span><span class="p">:</span> 
            <span class="n">velocity2</span> <span class="o">=</span> <span class="nf">model2</span><span class="p">(</span><span class="n">current2</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">t</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)).</span><span class="nf">cpu</span><span class="p">()</span>
            <span class="n">current2</span> <span class="o">=</span> <span class="n">current2</span> <span class="o">+</span> <span class="n">velocity2</span> <span class="o">*</span> <span class="n">dtw</span>
            <span class="nf">return </span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span> <span class="n">scatter2</span><span class="p">,)</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">scatter</span><span class="p">,)</span>
    
    <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="p">.</span><span class="nc">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                 <span class="n">frames</span><span class="o">=</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_file</span><span class="p">:</span>
        <span class="n">anim</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="sh">'</span><span class="s">ffmpeg</span><span class="sh">'</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">HTML</span><span class="p">(</span><span class="sa">f</span><span class="sh">"""</span><span class="s">&lt;center&gt;&lt;video height=</span><span class="sh">"</span><span class="s">350</span><span class="sh">"</span><span class="s"> controls loop&gt;&lt;source src=</span><span class="sh">"</span><span class="si">{</span><span class="n">save_file</span><span class="si">}</span><span class="sh">"</span><span class="s"> type=</span><span class="sh">"</span><span class="s">video/mp4</span><span class="sh">"</span><span class="s">&gt;
                      Your browser does not support the video tag.&lt;/video&gt;&lt;/center&gt;</span><span class="sh">"""</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">animation</span><span class="sh">'</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="sh">'</span><span class="s">jshtml</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">HTML</span><span class="p">(</span><span class="n">anim</span><span class="p">.</span><span class="nf">to_jshtml</span><span class="p">())</span>


<span class="n">save_file</span> <span class="o">=</span> <span class="sh">'</span><span class="s">images/fm_vs_rf_streamvecs.mp4</span><span class="sh">'</span>
<span class="nf">create_streamline_animation</span><span class="p">(</span><span class="n">val_points</span><span class="p">,</span> <span class="n">fm_model</span><span class="p">,</span> <span class="n">model2</span><span class="o">=</span><span class="n">reflowed_model</span><span class="p">,</span> <span class="n">n_frames</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">save_file</span><span class="o">=</span><span class="n">save_file</span><span class="p">)</span><span class="c1">#, show_points=True)</span></code></pre></figure> </details> <video width="100%" controls="" loop=""> <source src="/2025/assets/img/2025-04-28-flow-with-what-you-know/fm_vs_rf_streamvecs.mp4" type="video/mp4"></source> Your browser does not support the video tag. </video> <h1 id="connecting-with-other-models">Connecting with Other Models</h1> <h2 id="from-dots-to-images-audio-etc">From Dots to Images, Audio, etc..</h2> <p>How to move on from 2D dots to things like images, text, audio,…etc? We need only consider that the dimensionality of the velocity model is the same as that of the data itself. Put differently, one can regard the velocity model as supplying a tiny “change” to the data, whatever form that data is in. And the “straight line” trajectory used during training? That’s just linear interpolation between the (initially randomly-paired) source data and the target data. So for images, we will get a “velocity image”, which will tell us how to change the R,G,B values of every pixel in an image. This is where U-Nets and Attention come into play, to efficiently compute the “image-to-image” task of supplying a “velocity image” given an input image distribution (which may just be noise). For audio, regardless of the representation, the velocity model will tell us how to slightly change the component values in that representation. We then just integrate all the little changes as we did with the dots.</p> <ul> <li>The reader may wish to view an MNIST image example such as Tadao Yamaoka’s <d-cite key="rf_mnist_example"></d-cite>.</li> </ul> <h2 id="diffusion-models">Diffusion Models</h2> <p>Diffusion models, aka “score-based models,” share similarities with flow models in that both learn vector fields that transform points in the sample space. In “standard” diffusion models (DDPMs, <d-cite key="ddpm"></d-cite>), the process is stochastic, constantly injecting fresh noise to simulate Brownian motion <d-cite key="brownian_motion"></d-cite>, unlike the deterministic nature of flow models. However, diffusion models also admit deterministic sampling strategies, notably DDIM (Denoising Diffusion Implicit Models <d-cite key="ddim"></d-cite>), which follows a “probability flow ODE” without noise injection, making it more directly comparable to flow-matching. The key distinction is that flow-matching allows for more flexible choices of intermediate distributions and trajectories, while still sharing the same fundamental mathematical structure<d-footnote>Technically, the trajectory and the (variance of the) jitter would be the same quantity for diffusion models, and the choice of constant velocity during training is akin to a choice of (constant-total-amplitude) noise schedule. However, diffusion models and flow models are not fully equivalent, and I am a bit hesitant to delineate 1-to-1 correspondences between them.</d-footnote>. One practical difference is that curved flow-matching trajectories, being smooth, benefit greatly from higher-order integration schemes like RK4, whereas the non-smooth stochastic trajectories of standard diffusion models benefit less from such schemes. There are many more connections between diffusion models and flow-based models, however for brevity’s sake we’ll regard such further discussions as beyond the scope of this tutorial. For greater detail on the connections between diffusion models and flow-based models, we recommend the blog post by Gao et al <d-cite key="gao2025diffusionmeetsflow"></d-cite>.</p> <h2 id="optimal-transport">Optimal Transport</h2> <p>Interesting observation: See how the Reflowed streamlines in the last movie are approximately stationary (i.e., time-independent)? This connects nicely with Optimal Transport theory, where the Benamou-Brenier formulation <d-cite key="bb_form"></d-cite> (which has a diffusion-esque equation as on objective) shows that optimal mass transport paths follow constant-velocity geodesics in the Wasserstein metric space. This time-independence property emerges naturally when minimizing transport costs in simple metric spaces, as particles following straight paths at constant speeds achieve optimal transport between distributions.</p> <h2 id="normalizing-flows">Normalizing Flows</h2> <p>Normalizing flows have the property that they preserve overall probability throughout the flow process. While this would seem to be a nice constraint to satisfy, it appears to be unnecessary for “getting the job done” yet it may even limit the expressiveness of the model compared to the kinds of flows we’ve been talking about in this post. Note: Since I’m pushing a “physics perspective,” a similar “conservation” property arises in the phase space flows of Hamiltonian mechanics, namely that they preserve areas and volumes via Liousville’s Theorem <d-cite key="liouvilles_theorem"></d-cite>. The connection between normalizing flows and Hamiltonian systems was applied to generative modeling in the “Neural Hamiltonian Flows” paper of ICLR 2020 <d-cite key="Toth2020Hamiltonian"></d-cite>, and continues in a recent NeurIPS 2024 poster-paper <d-cite key="hamiltonian_flows"></d-cite>. Despite these fascinating connections, the exciting thing about flow-matching and rectified flows is that they seem to be effective even in the absence of the explicit conservation properties of normalizing flows and their relatives, and can thus be implemented quickly and simply.</p> <h1 id="summary">Summary</h1> <p>We’ve seen that flow matching and rectified flow models can be conceptualized and developed using simple ideas from basic physics. This simplicity, coupled with their power and flexibility, has fueled their rise to state-of-the-art performance. While the toy problem presented here is less demanding than applications like high-resolution image synthesis (for which readers should consult relevant literature<d-cite key="flux_paper"></d-cite>), we hope this introduction has developed your intuition for flow-based generative models. This foundation should help you follow the rapid progress in both academic and industry developments, and give you the confidence to expand on these ideas in your own investigations!</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/2025/assets/bibliography/2025-04-28-flow-with-what-you-know.bib"></d-bibliography> <d-article id="bibtex-container" class="related highlight"> For attribution in academic contexts, please cite this work as <pre id="bibtex-academic-attribution">
        PLACEHOLDER FOR ACADEMIC ATTRIBUTION
  </pre> BibTeX citation <pre id="bibtex-box">
        PLACEHOLDER FOR BIBTEX
  </pre> </d-article> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2025" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>